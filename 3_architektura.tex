\chapter{A megvalósított rendszer felépítése} \label{architektura_fejezet}

\section{Cv4s keretrendszer} \label{cv4s_keretrendszer}

\section{A \emph{cv4s} függőségei} \label{fuggosegek}

Az integráció megkezdése előtt feltétlen szükséges első lépés a \emph{cv4s} keretrendszer függőségeinek felderítése volt, a lehetséges platformok ezek ismeretében határozhatók meg. \\
\\
Lévén a keretrendszer C\# nyelven íródott, így feloldhatatlan függőséggel rendelkezik a \textit{CLR} felé, amely a kód futását biztosító menedzselt környezetet biztosítja. Ez a függőség kis mértékben korlátozza a platformfüggetlenséget, hiszen a virtuális gép 2015 óta nyílt forráskódú, így létezik implementációja a többek között \emph{GNU/Linux} operációs rendszerekre is. Valamelyeset azonban mégis szűkíti a felhasználhatóságot, hiszen feltételezi operációs rendszer jelenlétét az eszközünkön, ami beágyazott környezetben nem evidencia (kisebb komplexitású feladatok egyszerű ütemezővel is megoldhatók). Az így kizárásra kerülő a kisebb teljesítményű mikroszámítógépek azonban valószínűleg egyébként sem lettek volna alkalmasak a valós idejű képfeldolgozásra. \\
A másik \emph{.NET Standard}-függőségből származó korlátozás a \textit{Windows Presentation Foundation} (WPF) osztálykönyvtárat használó komponensek kiesése az integrációból, ugyanis a grafikus megjelenítésért felelős szoftver-egységek kizárólag \textit{Windows} operációs rendszer alatt érhetők el. A \emph{cv4s} keretrendszer alapvető funkcióit biztosító \code{Core} és \code{Operation} modulok csak kis mértékben függenek a \emph{WPF}-től így azok minimális változtatásával ezek is megszüntethetők.\\
\\
Az OpenCV és az azt közvetlenül használó OpenCvSharp felé jelentkező függőséget szintén fontos megvizsgálni, hiszen ezek feloldása nélkül a keretrendszer integrációja egyáltalán nem lehetséges. Az OpenCvSharp nyílt forráskódú, és bár hivatalosan az x86-os architektúrán kívül nem támogat más processzor típust, azonban keresztfordító alkalmazásával vagy egyből az eszközön fordítva használható ARM alapú processzoron is. Az OpenCvSharp egyfajta burkolóként (\emph{wrapper}) működik az OpenCV bináris könyvtára felett, így téve lehetővé a képfeldolgozó szolgáltatások használatát C\# nyelven, az eredeti C++ nyelvű implementáció hatékonyságával. Az OpenCV binárisok szintén -- lévén nyílt forráskódúak -- lefordíthatók ARM architektúrára is, hiszen a hivatalos fejlesztői \textit{repostry}-ban megtalálható a szükséges \code{Makefile}, így elvben nincs akadálya, hogy más processzor architektúrát használjunk. \\

\section{Lehetséges platformok}

A fenti megfontolások alapján két eszköz merült fel, mint lehetséges célhardver az integrációhoz:
\begin{itemize}
\item RaspberryPi 3 ARM architektúra
\begin{itemize}
\item Windows 10 IoT Core(\emph{Internet of Things}) operációs rendszerrel
\item Raspbian operációs rendszerrel
\end{itemize}
\item Intel Joule x86 architektúra
\begin{itemize}
\item Windows 10 IoT Core operációs rendszerrel
\item Ubuntu operációs rendszerrel 
\end{itemize}
\end{itemize}

Az eredeti, asztali környezettel a legtöbb hasonlóságot az Intel Joule-on futó Windows operációs rendszer mutatja, azonban jelentős hátrány, hogy az Intel már nem gyártja és nem támogatja a platformot.\\
\\
A Raspberry Pi ezzel szemben az egyik legnépszerűbb hardver a kezdő beágyazott fejlesztők között, ennek megfelelően részletes dokumentációval valamint széles felhasználói réteggel rendelkezik. Ezen felül a Win10 IoT Core, valamint saját Linux disztribúciója, a Raspbian is támogatja az eszközt.

\subsection{Raspberry Pi és Windows 10 IoT Core} \label{rpi-win10iot}

A \emph{.NET Framework} alapú képfeldolgozó keretrendszerünk számára remek környezetet lenne képes biztosítani a Microsoft beágyazott eszközökhöz fejlesztett operációs rendszere, amelyet a miénkhez hasonló IoT alkalmazásokhoz ajánlanak. A hivatalosan támogatott hardverek listáján megtaláljuk a Raspberry Pi 3-at is, és a Raspberry közösségi fóruma is sok segítséget biztosít a fejlesztéshez. \\
Kisebb akadályt jelent, hogy az OpenCV nem biztosít hivatalos \code{Makefile}-t a szoftverkönyvtár lefordításához Win10 IoT Core-ra, azonban a meglévő fájl kis mértékű módosításával áthidalható a probléma. \cite{win10-compile} Ezután az OpenCvSharp szoftvercsomag gond nélkül tudná használni a fordítás eredményeként kapott binárisokat. \\
Megjegyzendő, hogy, az operációs rendszer csak az \emph{Universal Windows Platform} (UWP) alkalmazásokat támogatja, ez a platform váltja le a korábban grafikus felületek létrehozására használt szoftverkönyvtárat, a \emph{Windows Presentation Foundation}-t (WPF), amelyet a \emph{cv4s} is alkalmaz. Ennek megfelelően a keretrendszer grafikus felülettel rendelkező alkalmazásai nem működnek a beágyazott rendszerben, bár ez nem is tipikus felhasználói eset.\\
Egy másik, a fejlesztést nehezítő tényező, hogy a Microsoft, bár kínál távoli képernyőelérést biztosító alkalmazást, a kipróbálásának időpontjában csak részlegesen működött, tényleges képernyőképet nem küldött a fejlesztői gépre. Megjegyzendő, hogy a Win 10 IoT Core a Microsoft viszonylag új terméke, de dinamikusan fejlődik, a későbbiekben mindenképpen érdemes megfontolni a használatát, a platform kiválasztásának időpontjában azonban nem ígérkezett optimális választásnak.

\subsection{Raspberry Pi és Raspbian}

A Raspbian egy Debian alapú operációs rendszer, amit kifejezetten a Raspberry Pi hardverére optimalizáltak. Mivel Linux alatt szükségünk van a futtató környezetre a C\# nyelven íródott programok számára, az alkalmazásunkat Mono vagy .Net Core segítségével tudjuk használni. Elsőre a .NET Core tűnt ideális választásnak, mert támogatja a projekt \code{build}-elését az eszközünkön is, kipróbálva viszont kiderült, hogy a \emph{WCF} egyáltalán nem került implementálásra, ez később a kommunikáció megvalósításánál jelentett gondot. \\
A Mono ezzel szemben a .NET Framework-öt valósítja meg, így szélesebb körű támogatást nyújt, egyetlen hiányossága, hogy nem implementálja a \ref{rpi-win10iot} alfejezetben említett \emph{WPF}-et. Ezen felül a Mono használata csak kisebb megkötést jelent, amelyekről a későbbi fejezetekben lesz szó.\\
\\
Végső soron a hardvernek és az operációs rendszernek ezt a kombinációját választottam, mint célplatform, egyrészt az OpenCV által biztosított, viszonylag egyszerű fordítási mód miatt, másrészt a korábbi tapasztalatom végett a Linux rendszerekkel. Ezen felül érdekesebb kihívást jelentett egy \textit{.NET Framework}-ben készült alkalmazás integrációja Linux rendszerre, ami nagyobb teret is biztosít a keretrendszer későbbi alkalmazásának akár asztali környezetben futó Linux környezetben is. Továbbá a fejlesztést is megkönnyítette a Raspbian-on elérhető VNC szerver, amivel a hálózatra kapcsolt eszköz grafikus felülete elérhető, valamint az \emph{ssh}-n keresztül elérhető, jól ismert Linux konzol.

\subsection{Intel Joule}

Az modul legnagyobb hátránya amellett, hogy felhagytak a gyártásával, az ára. A még kapható fejlesztői csomagok ára legalább duplája a Raspberry hasonló csomagjaihoz képest, ezért a kezdetektől fogva csak "B tervként" szerepelt. Megjegyzendő azonban, hogy lévén drágább termék, jobb teljesítményt is nyújt a kifejezetten gépi látással foglalkozó IoT megoldások számára. Ezzel együtt az alkalmazást nem teszteltük ezen a hardveren.

\section{Integráció}

Az alfejezetben az OpenCV és OpenCvSharp választott Raspberry/Raspbian eszközre való fordításáról illetve annak nehézségeiről lesz szó. Az itt tett megfontolások eredménye a \ref{rpi-build-script} számú függelékben megtalálható \emph{shell script}, amelyet az eszközünkön futtatva elérhetővé teszi a szükséges binárisokat a \emph{cv4s} futtatásához.

\subsection{OpenCV lefordítása}

A GNU/Linux rendszerek nagy része támogat valamilyen csomag menedzselő programot, amivel egyszerűen telepíthetőek és eltávolíthatóak az alkalmazások a függőségeik felderítésével (Red Hat Linux alapú rendszereken a \code{yum}, Debian alapú rendszereken az \code{apt}). Sajnos  Rasbian általam használt verziója alatt a hivatalos \emph{repository}-kban csak az OpenCV 3.2.0-nál korábbi verziók találhatóak meg, az OpenCvSharp pedig a 3.4.1-es kiadást támogatja, így a forráskód eszközön történő lefordítása mellett döntöttem, hogy ARM processzorral kompatibilis binárist kapjunk. Az OpenCV szoftvercsomag a \code{cmake} fordító rendszert használja, amely a bonyolult \code{Makefile}-okat hivatott kiváltani, azáltal, hogy egy könnyebben áttekinthető nyelv segítségével absztrahálja és automatikusan generálja őket.
A hivatalos OpenCV fejlesztői \code{repositry} biztosít egy \code{CMakeList} fájlt, amelyből a \code{cmake} programmal generálhatjuk le a szüksége \code{Makefile}-okat.\cite{opencv} A megfelelő működéshez szükséges azonban néhány parancssori konfigurációs kapcsoló beállítására, amivel az eszközünkre szabjuk a fordítás eredményét.\\
\\
A beállított kapcsolók:
\begin{itemize}
\item \code{OPENCV\_EXTRA\_MODULES\_PATH} az extra modulokat tartalmazó elérési út. Az OpenCV fejlesztői az új modulokat egy külön \textit{repostry}-ban tárolják, ezek olyan funkciók, amelyek nem lettek teljeskörűen tesztelve, vagy függvényeik fejléce még nem végleges.
\item \code{ENABLE\_NEON=ON} engedélyezi a \emph{NEON} használatát a lefordított kód számára. A \emph{NEON} az ARM processzorok architekturális kiegészítése a \textit{single instruction multiple data} (SIMD) műveletek végrehajtásához, ezáltal a képfeldolgozási feladatok hatékonyabb elvégzéséhez. Csak olyan processzorokon szabad engedélyezni, amelyek rendelkeznek ezzel a hardveres lehetőséggel.
\item \code{WITH\_LIBV4L=ON} engedélyezi a \code{libv4l} használatát a lefordított kód számára. A \code{libv4l} egy olyan szoftverkönyvtár, amely a Linux rendszerekben a videót feldolgozó alkalmazások számára biztosít egy absztrakciós réteget, ezáltal a különböző formátumok egységesen kezelhetők. Az OpenCvSharp videó-modulja számára van szükség erre a könyvtárra, ezt a fordítás előtt telepítenünk kell.
\item \code{CMAKE\_BUILD\_TYPE=Release} \textit{Release} módú kódot generál fordításkor.
\item \code{CMAKE\_INSTALL\_PREFIX} az eredményként kapott binárisok helyét határozza meg a fájlrendszerben.
\end{itemize}

\begin{mdframed}[backgroundcolor=gray!20]
\begin{small}
\begin{lstlisting}
cmake
-D OPENCV_EXTRA_MODULES_PATH='~/ocv_contrib-3.4.1/modules/'
-D ENABLE_NEON=ON -D WITH_LIBV4L=ON 
-D  CMAKE_BUILD_TYPE=Release
-D CMAKE_INSTALL_PREFIX='/usr/local' ..
\end{lstlisting}
\end{small}
\end{mdframed}

\subsection{OpenCvSharp lefordítása}

Az OpenCvSharp lefordítása viszonylag egyszerű a \code{cmake} segítségével, azonban a \code{CMakeLists.txt} fájlban szükséges beállítani a korábban lefordított OpenCV binárisok elérési útját az \code{include\_directories} között, a fordító csak így találja meg őket.\\
Miután a két osztott programkönyvtár létrejött, a \code{.exe} fájl mellé másolva használhatjuk az OpenCvSharp szolgáltatásait.

\subsection{Mono telepítése}

A Mono Debian csomagként telepíthető a Linux rendszereken megszokott \code{apt} csomagkezelő program segítségével.

\section{Tapasztalatok az integráció során}

A fordítást nehézkessé teszi, hogy a Raspberry Pi processzora lényegesen gyengébb, mint egy asztali számítógépé, így a fordítás kb. 5 órát vesz igénybe. Emiatt az elkészült \textit{script}-et asztali Linux környezetben teszteltem, mielőtt kipróbáltam volna a Raspberry Pi-n. \\
\\
A fejlesztés során egy kisebb kellemetlenség volt, hogy pár héttel azután, hogy 3.3.1-es OpenCV-t használó burkolót sikerült lefordítani és használni, kijött a 3.4.1-es verzióval működő OpenCvSharp, így a teljes fordítást újra kellett kezdeni. \\
\\
Egy másik furcsaság, amivel találkoztam, hogy bár a Raspberry Pi az SD-kártyán \code{ext4} fájlrendszert használ, egy hirtelen tápelvétel után inkonzisztens állapotban maradt, amit csak újratelepítéssel lehetett megoldani. Azért különös ez a jelenség, mert az \code{ext4} fájlrendszer használ naplózást, ami az ilyen hibák kivédésre való.\\
\\
Megjegyzendő még, hogy bár evidenciának tűnik, a fordítás sikerességén felbuzdulva könnyen elfelejthető, hogy a binárisok generálása után szükség van a \code{ldconfig} parancs kiadására is, amellyel frissítjük az osztott könyvtárakra mutató linkeket az operációs rendszer számára. Ha ezt nem tesszük meg, akkor bár mindent jól csináltunk, nem fog működni a \emph{cv4s} az eszközünkön.

\section{A megvalósított rendszer architektúrája} \label{architektura}

