\chapter{Beágyazott rendszerkomponens}

A \emph{cv4s} keretrendszer integrációja után egy olyan szoftvermodulon kezdtem el dolgozni, amely képes \textit{videostream}-en végzett valós idejű képfeldolgozásra a Raspberry Pi-n. 

\section{Követelmények}

Az alkalmazással szemben a feladat kiírása a távolról vezérelhetőséget, valamint a platformfüggetlenséget definiálja. \\
\\
Ezen felül igyekeztem a szoftver tervezésénél szem előtt tartani, hogy a megvalósított komponens a keretrendszerben már implementált képfeldolgozási műveleteket változtatás nélkül el tudja végezni, és ne legyen szerves része a távvezérelhetőséget biztosító modul, valamint általános videofájlt is fel tudjon dolgozni -- legyen az előre felvett videó, vagy valós idejű videofolyam.\\
\\
A széles körű konfigurálhatóság szintén fontos szempont volt, mert míg bizonyos alkalmazások esetén nem jelent problémát néhány képkocka elvesztése, a legfontosabb a valósidejűség, addig más alkalmazások az összes képkockán el kell hogy végezzék a műveletet a kívánt eredmény eléréséhez.\\
\\
A felhasználás során a távoli eszköz felügyeletére kevés lehetőség van, ezért a követelmények listájára felvettem a naplózást, amivel távoli számítógépen is lehetőség van a működés nyomon követésére.\\
\\
Mivel a Raspberry Pi viszonylag kis teljesítményű processzorral rendelkezik, szempont volt a négy processzormag minél egyenletesebb kihasználása, így mindenképpen egy több szálon futó alkalmazás létrehozására törekedtem.

\section{Megvalósított osztályok}

\subsection{\code{OperationPipeline} osztály}

Az \code{OperationPipeline} nevű osztály a megvalósított szoftverkomponens legfontosabb eleme, ugyanis ez a modul hajtja végre a beállított képfeldolgozási műveleteket, fogadja a felügyelő számítógépről érkező utasításokat, és kezeli a konfiguráció-változásokat. \\
A feldolgozás során egy FIFO (\textit{first-in first-out}) jellegű várakozási sorból veszi ki a képeket, majd miután végrehajtotta rajta a megadott sorrendben a beállított műveleteket egy kimeneti tárolóba teszi. A képfeldolgozási műveletek háttérszálon futnak, és miután befejeződtek \code{event}-en (eseményen) keresztül jeleznek, valamint lehetővé teszik a végrehajtási idő nyomon követését is. ezeket a szolgáltatásokat egy, a \emph{cv4s} részét képző, \code{CommandRunner} nevű osztály teszi lehetővé. Az \code{OperationPipeline} feliratkozik a \code{CommandRunner} eseményeire, és minden művelet végrehajtása után frissíti a következő végrehajtandó művelettel, illetve ha az egy képre vonatkozó összes művelet lefutott, összesíti futási időt, elmenti az eredményt, valamint új képet emel be feldolgozásra.\\
Az általános felhasználhatóságot szem előtt tartva a képfeldolgozó műveletekhez tartozik egy \code{bool} kapcsoló, amely az eljárás ciklikusságára vonatkozik. Ha ezt az értéket hamisra állítjuk valamely művelet esetén, az csak egy képre fog lefutni, utána kikerül a ciklusból.
A beállított műveletek közös \code{EntityContainer}-t használnak, amelyben a feldolgozandó kép a \code{WellKnownTagNames.Selected} címkével kell, hogy rendelkezzen. A képfeldolgozási ciklus végén ebből a tárolóból kerül ki az adott képkockából kapott eredmény, a soron következő kép pedig a tároló ürítése után kerül be a konténerbe. \\
Minden egyes végrehajtási ciklus során összegződik a műveletek időigénye, ez alapján pedig a szoftverkomponens kiszámítja a legmagasabb elérhető \emph{frame per second} (FPS) értéket. Ha az aktuálisan beállított olvasási sebesség magasabb, mint a konfigurációval elérhető legmagasabb, akkor az FPS értéket az maximális értékre állítja, hogy ne halmozódjanak fel képek a bemeneti tárolóban.\\
A szoftverkomponens futása során lehetőség van a konfiguráció változtatására új műveletek hozzáadásával, illetve kivételével. A tesztelés során hibát lehetett előidézni, ha a képfeldolgozási ciklus közben változtattunk a konfiguráción. Ennek kiküszöbölésére a műveletek egy köztes tárolót változtatnak, amely a módosításának következtében kiadott eseménnyel beállít egy jelzőbitet, hogy új konfiguráció érkezett. A ciklus végén bekövetkező esemény emeli be az új konfigurációt, és a következő képen már az új műveletek fognak lefutni.\\
Előfordulhat a működés során, hogy elfogynak a feldolgozandó képek, vagy a beállított konfiguráció nem tartalmaz több végrehajtandó műveletet. Ilyenkor a szoftvermodul várakozó állapotba kerül, amiből valamelyik tároló által kiváltott esemény hatására lép ki.

\subsection{Tároló osztályok}

Az alkalmazás két, részben általam megvalósított tároló osztályt tartalmaz, amelyek a műveleteket, illetve feldolgozandó képeket tartalmazzák, a nevük \code{OperationList} és \code{EntityQueue}. Ezek standard .NET Framework \code{List} és \code{Queue} tárolókból származnak le, ahogy a nevük is mutatja.\\
Azért volt szükség a meglévő megoldások bővítésére, mert az átnevezéssel egyrészt szükség volt a meglévő funkciók bővítésére, másrészt pedig áttekinthetőbbé vált a forráskód. Mindkét osztály megvalósítja a \code{INotifyPropertyChanged}  interfészt, így a belső változások által kiváltott eseményekre más osztályok fel tudnak iratkozni. Megjegyzendő, hogy ezt a \code{ObservableCollection} generikus tárolóból való leszármaztatással is meg lehetett volna oldani.

\paragraph{\code{OperationList}}
Az osztály -- megtévesztő módon -- nem közvetlenül a műveleteket tárolja, hanem egy, a műveletből és \code{bool} kapcsolóból álló pár-objektumokat. A deklaráció a következőképp néz ki:
\begin{scriptsize}
\begin{lstlisting}[language=java]
public class OperationList : List<Tuple<Operation, bool>>, INotifyPropertyChanged
\end{lstlisting}
\end{scriptsize}

A \code{List} tartalmát módosító metódusok kiegészülnek az esemény kiadásával, illetve kibővültek az \code{Update} nevű művelettel, amely a teljes tartalom frissülése után egyszer váltja ki az eseményt.

\paragraph{\code{EntityQueue}} egy, a \emph{cv4s} keretrendszer által használt, \code{Entity} nevű objektumokat tároló várakozási sor. A .NET \code{ConcurentQueue} osztályát bővíti ki a következő funkciókkal:
\begin{itemize}
\item fent leírt módon az \code{INotifyPropertyChanged} interfész megvalósítása
\item limitált számú elem tárolása.
\end{itemize}
A várakozási sort több szál is módosíthatja, így a versenyhelyzetek okozta inkonzisztencia elkerülés érdekében az tároló atomi módon módosítható. Az elemszám limitálására azért volt szükség, hogy az adott alkalmazásra szabható módon (az FPS-sel együtt) szabályozható legyen, hogy veszítünk-e el képkockát az esetlegesen lassú feldolgozás során.

\subsection{\code{CameraReader} osztály}

Az szoftvermodul az elnevezésének megfelelően a egy videófolyamból olvas ki képkockákat a beállított ütemben. Az osztály megvalósítja a \code{IVideoReader} interfészt, ami némi rugalmasságot biztosít a felhasználást illetően más alkalmazásokban. \\
A képek kiolvasásához az OpenCV \code{VideoCapture} osztályát használtam. Az osztállyal kapcsolatban megjegyzendő, hogy ha ARM platformon akarjuk használni mindenképp szükség van az OpenCvSharp \code{ffmpeg.dll} fájljaira, amelyek a videók feldolgozásáért felelős \textit{assembly}-k.\\
Annak érdekében, hogy a működés során a CPU magok minél egyenletesebb terhelésnek legyenek alávetve a képfeldolgozáson kívül a képek kiolvasása is háttérszálon történik. Miután a modul elhelyezte a képkockát a kimeneti tárolójába, megadott ideig alvó állapotba lép. A várakozási állapotban eltöltött idő hossza állítható, így szabályozható a feldolgozás sebessége. A \code{CameraReader} tartalmaz egy referenciát egy ugyanolyan tároló osztályra, mint az \code{OperationPipeline} bemeneti tárolója, így összefűzhető a képkocka útja az alkalmazásban.\\
Sajnos ahhoz, hogy a feldolgozási sebesség állítható legyen, az \code{OperationPipeline} referenciával rendelkezik egy \code{CameraReader} példányra -- még csak nem is \code{IVideoReader}-re, mivel az biztosít lehetőséget az FPS szabályozására --, ez kissé csökkenti az általános felhasználhatóságot.

\begin{figure}[h]
\includegraphics[scale=0.5]{doggy.png}
\centering
\caption{Az alkalmazás vázlatos működése}
\label{fig:doggy}
\end{figure}

\section{Naplózás}

\section{Automatizált tesztelés}


\section{Tapasztalatok a fejlesztés során}

Furcsa és nehezen detektálható hiba volt, hogy a szoftverkomponenst Mono-val futtatva \code{Segmentation Fault} hibaüzenetet dobott. A probléma oka az volt, hogy a Mono nem tudja értelmezni a C\# 7.0-ban bevezetett \textit{Value Tuple} struktúrát, ami a kód olvashatóságát hivatott javítani azáltal, hogy a tárolt elemek a korábbi \code{Item1}, \code{Item2} stb. tulajdonság helyett névvel is hozzáférhetők. A probléma detektálása után refaktoráltam a kódot, hogy az olvasható \code{(Operation Operation, bool Repeatable)} formában lévő parancsleírást helyettesítettem a kevésbé átlátható \code{Tuple<Operation, bool>()} definícióval. \\