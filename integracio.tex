\chapter{A keretrendszer integrációja} \label{integracio}

\section{A \emph{cv4s} függőségei}

Az integráció megkezdése előtt feltétlen szükséges első lépés a \emph{cv4s} keretrendszer függőségeinek felderítése volt, a lehetséges platformok ezek ismeretében határozhatók meg. \\
\\
Lévén a keretrendszer C\# nyelven íródott, így feloldhatatlan függőséggel rendelkezik a \textit{.NET Framework} felé, amely a kód futását biztosító menedzselt környezetet biztosítja. Ez a függőség kis mértékben korlátozza a platformfüggetlenséget, hiszen a keretrendszer 2015 óta nyílt forráskódú, így létezik implementációja a többek között \emph{GNU/Linux} operációs rendszerekre is. Valamelyeset azonban mégis szűkíti a felhasználhatóságot, hiszen feltételezi operációs rendszer jelenlétét az eszközünkön, ami beágyazott környezetben nem evidencia (kisebb komplexitású feladatok egyszerű ütemezővel is megoldhatók). Az így kizárásra kerülő a kisebb teljesítményű mikroszámítógépek azonban valószínűleg egyébként sem lettek volna alkalmasak a valós idejű képfeldolgozásra. \\
A másik \emph{.NET Framework}-függőségből származó korlátozás a \textit{Windows Presentation Foundation} (WPF) osztálykönyvtárat használó komponensek kiesése az integrációból, ugyanis a grafikus megjelenítésért felelős szoftverkomponensek kizárólag \textit{Windows} operációs rendszer alatt érhetők el. A \emph{cv4s} keretrendszer alapvető funkcióit biztosító \code{Core} és \code{Operation} modulok csak kis mértékben függenek a \emph{WPF}-től így azok minimális változtatásával ezek is megszüntethetők.\\
\\
Az OpenCV és az azt közvetlenül használó OpenCvSharp felé jelentkező függőséget szintén fontos megvizsgálni, hiszen ezek feloldása nélkül a keretrendszer integrációja egyáltalán nem lehetséges. Az OpenCvSharp nyílt forráskódú, és bár hivatalosan az x86-os architektúrán kívül nem támogat más processzor típust, azonban keresztfordító alkalmazásával vagy egyből az eszközön fordítva használható ARM alapú processzoron is. A burkoló modul által használt OpenCV binárisok szintén lefordíthatók a ARM architektúrára, hiszen a hivatalos fejlesztői \textit{repostry}-ban megtalálható a szükséges \code{Makefile}, így elvben nincs akadálya, hogy ARM alapú processzort használjunk. \\

\section{Lehetséges platformok}

A fenti megfontolások alapján két eszköz merült fel, mint lehetséges célhardver az integrációhoz:
\begin{itemize}
\item RaspberryPi 3 ARM architektúra
\begin{itemize}
\item Windows 10 IoT Core(\emph{Internet of Things}) operációs rendszerrel
\item Raspbian operációs rendszerrel
\end{itemize}
\item Intel Joule x86 architektúra
\begin{itemize}
\item Windows 10 IoT Core operációs rendszerrel
\item Ubuntu operációs rendszerrel 
\end{itemize}
\end{itemize}

Az eredeti, asztali környezettel a legtöbb hasonlóságot az Intel Joule-on futó Windows operációs rendszer mutatja, azonban jelentős hátrány, hogy az Intel már nem gyártja és nem támogatja a platformot.\\
\\
A Raspberry Pi ezzel szemben az egyik legnépszerűbb hardver a kezdő beágyazott fejlesztők között, ennek megfelelően részletes dokumentációval valamint széles felhasználói réteggel rendelkezik. Ezen felül a Win10 IoT Core, valamint saját Linux disztribúciója, a Raspbian is támogatja az eszközt.

\subsection{Raspberry Pi és Windows 10 IoT Core} \label{rpi-win10iot}

A \emph{.NET Framework} alapú képfeldolgozó keretrendszerünk számára remek környezetet lenne képes biztosítani a Microsoft beágyazott eszközökhöz fejlesztett operációs rendszere, amelyet a miénkhez hasonló IoT alkalmazásokhoz ajánlanak. A hivatalosan támogatott hardverek listáján megtaláljuk a Raspberry Pi 3-at is, és a Raspberry közösségi fóruma is sok segítséget biztosít a fejlesztéshez. \\
Kisebb akadályt jelent, hogy az OpenCV nem biztosít hivatalos \code{Makefile}-t a szoftverkönyvtár lefordításához Win10 IoT Core-ra, ám ez is megoldható. \cite{win10-compile} Ezután az OpenCvSharp szoftvercsomag gond nélkül tudná használni a fordítás eredményeként kapott binárisokat. \\
Megjegyzendő, hogy, az operációs rendszer csak az \emph{Universal Windows Platform} (UWP) alkalmazásokat támogatja, ez a platform váltja le a korábban grafikus felületek létrehozására használt szoftverkönyvtárat, a \emph{Windows Presentation Foundation}-t (WPF), amelyet a \emph{cv4s} is alkalmaz. Ennek megfelelően a keretrendszer grafikus felülettel rendelkező alkalmazásai nem működnek a beágyazott rendszerben, bár ez nem is tipikus felhasználói eset.\\
Egy másik, a fejlesztést nehezítő tényező, hogy a Microsoft, bár kínál távoli képernyőelérést biztosító alkalmazást, a kipróbálásának időpontjában csak részlegesen működött, tényleges képernyőképet nem küldött a fejlesztői gépre.

\subsection{Raspberry Pi és Raspbian}

A Raspbian egy Debian alapú operációs rendszer, amit kifejezetten a Raspberry Pi hardverére optimalizáltak. Mivel Linux alatt szükségünk van a futtató környezetre, az alkalmazásunkat Mono segítségével tudjuk használni. A Mono nem implementálja a \ref{rpi-win10iot} alfejezetben említett WPF-et, de ez nem jelent problémát az ott leírt okok miatt. Ezen felül a Mono használata csak kisebb megkötést jelent, amelyekről a későbbi fejezetekben lesz szó.\\
\\
Végső soron a hardvernek és az operációs rendszernek ezt a kombinációját választottam, mint célplatform, egyrészt az OpenCV által biztosított, viszonylag egyszerű fordítási mód miatt, másrészt a korábbi tapasztalatom végett a Linux rendszerekkel. Ezen felül érdekesebb kihívást jelentett egy \textit{.NET Framework}-ben készült alkalmazás integrációja Linux rendszerre, ami nagyobb teret is biztosít a keretrendszer későbbi alkalmazásának akár asztali környezetben futó Linux környezetben is. Továbbá a fejlesztést is megkönnyítette a Raspbian eszköztára (pl. távoli elérés).

\subsection{Intel Joule}

Az modul legnagyobb hátránya amellett, hogy felhagytak a gyártásával, az ára. A még kapható fejlesztői csomagok ára legalább duplája a Raspberry hasonló csomagjaihoz képest, ezért a kezdetektől fogva csak "B tervként" szerepelt. Megjegyzendő azonban, hogy lévén drágább termék, jobb teljesítményt is nyújt a kifejezetten gépi látással foglalkozó IoT megoldások számára. Ezzel együtt az alkalmazást nem teszteltük ezen a hardveren.

\section{Integráció}

Az alfejezetben az OpenCV és OpenCvSharp választott Raspberry/Raspbian eszközre való fordításáról illetve annak nehézségeiről lesz szó. Az itt tett megfontolások eredménye a \ref{rpi-build-script} számú függelékben megtalálható \emph{shell script}, amelyet az eszközünkön futtatva elérhetővé teszi a szükséges binárisokat a \emph{cv4s} futtatásához.

\subsection{OpenCV lefordítása}

A képfeldolgozó műveletekhez szükség van lefordítani a Raspberry Pi-re az OpenCV forráskódját, ezt a legegyszerűbben magán az eszközön végezhetjük el, hogy ARM processzorral kompatibilis binárist kapjunk. A hivatalos OpenCV fejlesztői repostry biztosít egy \code{Makefile}-t, amelyet a \code{cmake} programmal használhatunk a fordításhoz.\cite{opencv} A megfelelő működéshez szükséges néhány kapcsoló beállítására, amivel az eszközünkre szabjuk a fordítás eredményét.\\
\\
A beállított kapcsolók:
\begin{itemize}
\item \code{OPENCV\_EXTRA\_MODULES\_PATH} az extra modulokat tartalmazó elérési út. Az OpenCV fejlesztői az új modulokat egy külön \textit{repostry}-ban tárolják, ezek olyan funkciók, amelyek nem lettek teljeskörűen tesztelve, vagy függvényeik fejléce még nem végleges.
\item \code{ENABLE\_NEON=ON} engedélyezi a \emph{NEON} használatát a lefordított kód számára. A \emph{NEON} az ARM processzorok architekturális kiegészítése a \textit{single instruction multiple data} (SIMD) műveletek végrehajtásához, ezáltal a képfeldolgozási feladatok hatékonyabb elvégzéséhez. Csak olyan processzorokon szabad engedélyezni, amelyek rendelkeznek ezzel a hardveres lehetőséggel.
\item \code{WITH\_LIBV4L=ON} engedélyezi a \code{libv4l} használatát a lefordított kód számára. A \code{libv4l} egy olyan szoftverkönyvtár, amely a Linux rendszerekben a videót feldolgozó alkalmazások számára biztosít egy absztrakciós réteget, ezáltal a különböző formátumok egységesen kezelhetők. Az OpenCvSharp videó-modulja számára van szükség erre a könyvtárra, ezt a fordítás előtt telepítenünk kell.
\item \code{CMAKE\_BUILD\_TYPE=Release} \textit{Release} módú kódot generál fordításkor.
\item \code{CMAKE\_INSTALL\_PREFIX} az eredményként kapott binárisok helyét határozza meg a fájlrendszerben.
\end{itemize}

\subsection{OpenCvSharp lefordítása}

Az OpenCvSharp lefordítása viszonylag egyszerű a \code{cmake} segítségével, azonban a \code{CMakeLists.txt} fájlban szükséges beállítani a korábban lefordított OpenCV binárisok elérési útját az \code{include\_directories} között, a fordító csak így találja meg őket.\\
Miután a két osztott programkönyvtár létrejött, a \code{.exe} fájl mellé másolva használhatjuk az OpenCvSharp szolgáltatásait.

\subsection{Mono telepítése}

A Mono Debian csomagként telepíthető a Linux rendszereken megszokott \code{apt} csomagkezelő program segítségével.

\section{Tapasztalatok az integráció során}

A fordítást nehézkessé teszi, hogy a Raspberry Pi processzora lényegesen gyengébb, mint egy asztali számítógépé, így a fordítás kb. 5 órát vesz igénybe. Emiatt az elkészült \textit{script}-et asztali Linux környezetben teszteltem, mielőtt kipróbáltam volna a Raspberry Pi-n. \\
\\
A fejlesztés során egy kisebb kellemetlenség volt, hogy pár héttel azután, hogy 3.3.1-es OpenCV-t használó burkolót sikerült lefordítani és használni, kijött a 3.4.1-es verzióval működő OpenCvSharp, így a teljes fordítást újra kellett kezdeni. \\
\\
Egy másik furcsaság, amivel találkoztam, hogy bár a Raspberry Pi az SD-kártyán \code{ext4} fájlrendszert használ, egy hirtelen tápelvétel után inkonzisztens állapotban maradt, amit csak újratelepítéssel lehetett megoldani. Azért különös ez a jelenség, mert az \code{ext4} fájlrendszer használ naplózást, ami az ilyen hibák kivédésre való.\\
\\
Megjegyzendő még, hogy bár evidenciának tűnik, a fordítás sikerességén felbuzdulva könnyen elfelejthető, hogy a binárisok generálása után szükség van a \code{ldconfig} parancs kiadására is, amellyel frissítjük az osztott könyvtárakra mutató linkeket az operációs rendszer számára. Ha ezt nem tesszük meg, akkor bár mindent jól csináltunk, nem fog működni a \emph{cv4s} az eszközünkön.

