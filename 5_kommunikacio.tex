\chapter{Kommunikáció} \label{chapter:kommunikacio}
\section{Windows Communication Foundation}
Az eszköz távirányíthatóságát a .NET Framework \emph{Windows Communication Foundation} (WCF) nevű, szolgáltatás-orientált keretrendszerének segítségével oldottam meg. A rugalmasságot szem előtt tartva igyekeztem teljesen elkülöníteni a távoli vezérelhetőséget, illetve a \ref{chapter:kepfeldolgozo} fejezetben bemutatott képfeldolgozási funkciókat biztosító osztályokat.\\

Az elkészített szoftverkomponens bemutatása előtt pár szó a WCF-ről, illetve a mögötte lévő szoftvertervezési filozófiáról. A \ref{ssection:wcf_intro} számú bevezetőben leírt szolgáltatás-orientált szemlélet szerint készült C\# nyelven írt alkalmazások támogatására a Microsoft a WCF keretrendszert hozta létre. A keretrendszer menedzselt futási környezetet biztosít a szolgáltatások számára, amelyen keresztül azok CLR típusokat tehetnek közzé, illetve a fogadott adatot CLR típusként reprezentálhatják. Az alkalmazás komponensei nem igénylik a közös operációs rendszert, programozási nyelvet, de még azt sem, hogy egy számítógépen fussanak, elegendő a megfelelően konfigurált adatkapcsolat illetve a programozási felület (\emph{API}) ismerete. A WCF terminológiája az szoftver-egységet \emph{service}-nek (magyarul szolgáltatásnak) nevezi, és a szolgáltatás-orientált több ilyen egységet aggregál, miközben ezen egységek függőségei minimálisak. A \emph{service} ugyanis nem más mint funkcionalitások összessége, amit a komponens elérhetővé tesz a többi szolgáltatás számára, leegyszerűsítve távolról hívható függvény gyűjtemények, melyek egymástól függetlenül karban tarthatók (hasonlóan az objektumorientált szemlélet által bevezetett osztályokhoz, azonban kisebb mértékű csatolással).\\

Az így létrejövő struktúrában a szolgáltatások mellett megjelennek az őket igénybe vevő kliensek (\emph{client}), amelyek gyakorlatilag bármilyen formát ölthetnek --  Windows Forms, ASP.NET alkalmazás vagy a mi esetünkben WPF (\ref{chapter:kliens} fejezet). A \emph{service-client} architektúrában a komponenseknek egymásról csak korlátozottan van információjuk és aszinkron módon üzenetekkel kommunikálnak. A kliensek a szolgáltatások funkcionalitását és jellemzően a WCF által biztosított \emph{metaadat cserén} keresztül ismerik meg. A metaadat valamilyen technológia-független módon kerül közzétételre, és tartalmazza az adott szolgáltatás által nyújtott funkcionalitásokat, valamint a kommunikáció lehetséges módjait. \\

A szolgáltatás-kliens struktúrában az esetek döntő többségében csak a kliens hívhatja meg a \emph{service} metódusait, a fordított irányú kommunikáció megvalósítására a \ref{subs:rpi_log_service} alfejezetben látható példa. Általában -- és erre a megvalósított rendszernél is ki fogok térni-- a kliens nem közvetlenül a szolgáltatással kommunikál, hanem egy proxy-objektummal, amely ugyanazokkal a funkcionalitásokkal rendelkezik, mint a \emph{service} és ezen felül memória-kezelő tulajdonságai is vannak. Természetesen futási időben megismert szolgáltatás esetében nincs lehetőség a proxy-objektum definiálásra és betöltésére a memóriában, ilyenkor közvetlen kapcsolatot is létre lehet hozni a \emph{service}-szel. \cite{wcf-programming}
\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.25]{wcf_abc.pdf}
\centering
\vspace{.2cm}
\caption{WCF végpont}
\vspace{.5cm}
\label{fig:wcf_abc}
\end{figure}

Egy szolgáltatásnak a következő három három összetevőt kell definiálnia az egyértelmű azonosíthatóság érdekében:
\paragraph{Address} Minden szolgáltatáshoz tartoznia kell egy egyedi címnek, amely két fontos részletében hordoz információt a kliens számára, méghozzá a meghatározza a \emph{service} helyét (a lokális számítógépen vagy a hálózaton), illetve a kommunikáció módját az alkalmazott protokoll által. A cím mindig a következő formában írható fel:

\begin{mdframed}[backgroundcolor=gray!20]
\begin{scriptsize}
\begin{lstlisting}[language=bash]
[transport]://[machine or domain][:optional port]/[optional URI]
\end{lstlisting}
\end{scriptsize}
\end{mdframed}

A WCF által támogatott, általam használt kommunikációs sémák a HTTP/HTTPS és a TCP. (Ha lokális gépen futó kliens számára szeretnénk szolgáltatást \emph{host}-olni, az IPC (\emph{inter-process communication}), MSMQ (\emph{Microsoft Message Queue}, illetve a Service Bus kommunikációs protokollok valamelyike lehet a jó megoldás.)
\paragraph{Binding} A szolgáltatással való kommunikáció több szempontból is eltérő lehet, és sokrétűen konfigurálható. A kommunikáció iránya, az üzenetek szinkronitása és a fogadás módja szerint is részletekbe menő beállításokra van szükség a kommunikációs séma teljes körű definiáláshoz. A legtöbb alkalmazásban nincs szükség minden paraméter részletekbe menő beállítására, erre a keretrendszer előre definiált megoldásokat kínál a leggyakoribb sémákra, amelyek a fentebb leírt kommunikációs protokollokra definiálnak egy-egy sémát, amelyet igény szerint tovább finomíthatunk.
\paragraph{Contract} Platformfüggetlen \emph{szerződésként} írja le a szolgáltatás képességeit a kliens számára. Az objektumorientált szemléletben használt interfészekkel állítható párhuzamba -- megvalósítása objektumorientált nyelven (esetünkben C\#) gyakorlatilag is interfészekkel történik. A WCF négyféle \emph{contract} típust definiál, melyek a 
\begin{itemize}
\setlength\itemsep{.1em}
\item \emph{Service contract} Meghatározza, milyen funkcionalitásokra képes a szolgáltatás. Az osztályunk által definiált CLR interfészt összerendeli a szolgáltatás technológia-független interfészével. 
\item \emph{Data contract} A szolgáltatás által használt adattípusukat definiálja. A CLR beépített típusai alapértelmezetten ismertek a keretrendszer számára.
\item \emph{Fault contract} A \emph{service} oldali hibák kliens oldalon való jelzésére szolgáló megegyezés.
\item \emph{Message contract}. Szolgáltatások közvetlen, üzenet alapú kölcsönhatását teszi lehetővé. 
\end{itemize}
Ezek közül a lehetőségek közül a diplomamunkámban két típust, a \emph{service} és \emph{data contract}-ot használtam fel.

E három komponens együttesen egy \emph{végpontot} (\emph{endpoint}-ot) definiál a \ref{fig:wcf_abc} ábrán látható módon.
A végpontot azonosító három összetevő egyenként is számos eltérő beállítási lehetőséget nyújt, azonban összességében nézve szinte teljeskörűen az alkalmazásra szabható konfigurációt kapunk.\\
Fontos megjegyezni, hogy minden \emph{service}-hez tartoznia kell legalább egy -- de akár több -- \emph{endpoint}-nak. A szolgáltatást futtató \emph{host} ezeket a végpontokat teszi elérhetővé a kliensek számára a már említett metaadat cserén keresztül. A kliens a metaadathoz is a szolgáltatás speciális, \emph{MEX}, azaz \emph{metadata exchange} végpontján keresztül fér hozzá. A végpontok konfigurációja a szolgáltatás megvalósítása során az egyik legfontosabb lépés, erre a WCF keretrendszer két módot is kínál: programkódból történő, illetve adminisztratív beállítást. A különbség a két módszer között annyi, hogy míg az előbbi esetben a konfigurációt reprezentáló objektumokat a forráskódban explicit létrehozzuk, az utóbbi módszerrel a példányosítást a keretrendszerre bízzuk, az egyes paramétereket pedig XML formátumú konfigurációs fájlban adjuk át neki. Az utóbbi eset jelentős előnye, hogy a szoftver ebben az esetben nem függ a kommunikáció paramétereitől, a konfiguráció-változtatás pedig a gyakorlatban egyetlen fájl cseréjét jelenti. \cite{wcf-doc} \\
\\
A WCF architektúrában az üzenetek eljuttatása a klienstől a szolgáltatásig a \ref{fig:wcf_architekture} ábrán bemutatott módon, úgynevezett \code{Channel} objektumokon keresztül történik. Látható, hogy a kliens vagy egy helyettes, a szolgáltatást reprezentáló objektumon keresztül vagy közvetlenül kommunikál a legfelső \code{Channel}-lel. Ezek az objektumok reprezentálják a konfigurációnak megfelelő kommunikáció egyes lépéseit, a klienstől jövő üzeneteket a transzport csatornáig eljutva a megfelelő formátumúra alakítják; struktúrájuk nagyrészt a \emph{Binding} konfigurációjától függ. A \emph{service} oldalon az üzenet fordított sorrendben végrehajtva az előző transzformációkat visszakapjuk a kliens üzenetét, amit a \code{Dispatecher} objektum ad át a szolgáltatás megfelelő végpontján. A \emph{service}-t valójában közvetlenül egy lokális kliens hívja meg -- a diszpécser. A szolgáltatás által a hívásra adott válasz a \ref{fig:wcf_architekture} ábrán látható úton ellentétes irányban jut el a klienshez. \cite{wcf-programming}

\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.1]{wcf_architekture.pdf}
\centering
\vspace{.2cm}
\caption{WCF kommunikációs architektúra}
\vspace{.5cm}
\label{fig:wcf_architekture}
\end{figure}

A kliens oldali modul elvárt működésének érdekében a Visual Studio-ban \code{Service Reference} hozzáadása szükséges a projektünkhöz Itt a szolgáltatás elérési címének megadása után megjelenik a kívánt \code{service}, és a VisualStudio automatikusan legenerálja a metaadat alapján a \ref{fig:wcf_architekture} ábrán látható kliens oldali kódot a \emph{service} használatához. Ha nem Visual Studio-t használunk lehetőség van az \code{svcutil} parancssori program alkalmazására, ami elvégzi a szolgáltatásunk kliens oldali kódjának létrehozását. A szolgáltatás létrehozásakor a WCF keretrendszer szolgáltatja a szükséges objektumokat.\\

A diplomaterv keretében megvalósított alkalmazás esetén a Raspberry Pi-n futó képfeldolgozó szoftver látja el a  \emph{service} szerepét, a felügyelő feladatot ellátó, asztali gépen futó alkalmazás pedig kliensként veszi igénybe annak szolgáltatásait, amelyeket a \ref{section:servicek} alfejezet részletez.

\section{Kommunikációs protokoll}

A keretrendszer kiválasztása után, az implementálás előtti utolsó lépés a kommunikációs protokoll tisztázása volt. A WCF által támogatott hálózati protokollok közül a TCP és a HTTP közül mindkettő jó választás lehet, a weben HTTP szélesebb körben támogatott, alkalmazásrétegbeli protokoll, a TCP pedig ipari alkalmazásokhoz jobban illeszkedő, szállítási rétegbeli protokoll. A WCF konfigurációja lehetővé teszi, hogy a fejlesztő számára a különbség csak a konfigurációs fájl szintjén jelentkezzen, ezért az implementál szolgáltatások számára mindkét protokollon keresztül nyitottam egy-egy végpontot.\\
A leírt hálózati kapcsolaton menő üzenetek tartalmát az XML-alapú \emph{SOAP} üzenetek (\emph{Simple Object Access Protocol}) határozza meg. A SOAP speciálisan webszolgáltatások számára kifejlesztett, strukturált adatot tartalmazó üzenetekkel kommunikáló protokoll, amely a már említett WSDL-hez hasonlóan valamilyen alkalmazásrétegbeli protokoll fölött működik. Egyes webes szolgáltatások számára a SOAP túlságosan merev, összehasonlítva a REST kommunikációs architektúra kínálta rugalmassággal. SOAP használata esetén ugyanis a \emph{service} és a \emph{client} együttes, párhuzamos fejlesztése a legcélravezetőbb a nagyfokú csatoltság miatt. A Raspberry-n futó képfeldolgozó alkalmazás esetében szerencsére ez a helyzet, és a WCF esetében is ez az alap beállítás, így végül majdnem minden megvalósított szolgáltatás a \code{BasicHttpBinding} kötést használja eltérő beállításokkal. A keretrendszer több, HTTP kapcsolat kialakítására szolgáló \emph{binding} objektumot is biztosít (\code{}, \code{} ), de azok interoperabilitása korlátozott, így az alap szolgáltatások mellett döntöttem.\\
A SOAP üzenetek technológia független módon képesek üzenet alapú kommunikációra. Három főbb érszből áll:
\begin{itemize}
\item egy \emph{boríték}, mely a az üzenet struktúrát és a feldolgozás módját definiálja
\item az alkalmazás-specifikus adattípusokra vonatkozó kódolás
\item a távoli eljárások hívására és a válaszok formátumára vonatkozó megegyezés
\end{itemize}
A protokoll üzeneteinek struktúrája a \ref{figure:soap_message} ábrán látható. A WCF keretrendszer az üzeneteket a megfelelő \emph{binding}-nak megfelelően a háttérben előállítja, így alapesetben a fejlesztőnek nem kell ismernie, viszont a program Raspbian-ra való integrálása során a nem megfelelő üzenetformátumból adódtak problémák. A SOAP-üzenetek megvizsgálása után a kapcsolat paramétereinek megfelelő változtatása orvosolta a problémát.

\begin{figure}[h]
\centering
\begin{minipage}{0.73\textwidth}
\begin{mdframed}[backgroundcolor=gray!20]
\begin{scriptsize}
\begin{lstlisting}[language=XML]
<?xml version="1.0"?>
<soap:Envelope xmlns:soap=
  "http://www.w3.org/2003/05/soap-envelope">
  <soap:Header>
  	<!-- Header nodes -->
  </soap:Header>
  <soap:Body>
    <!-- Object properties -->
  </soap:Body>
</soap:Envelope>
\end{lstlisting}
\end{scriptsize}
\end{mdframed}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}{0.21\textwidth}
\includegraphics[height=4.3cm]{soap_message.pdf}
\end{minipage}
\caption{SOAP üzenetek felépítése}
\label{figure:soap_message}
\end{figure}

\section{Szolgáltatások} \label{section:servicek}
A WCF dokumentációja szolgáltatások létrehozására megvalósítására két lehetséges módot biztosít: a \emph{service} deklarálása interfészként vagy osztályként. Mindenkét esetben a \code{[ServiceContract]} attribútumot kell alkalmazni az adott típusra, de az újrafelhasználhatóság szempontjából az interfészek használata a javasolt, így a diplomamunkámban a dokumentáció iránymutatását követtem. \cite{wcf-doc} \\
Összesen négy darab \emph{Service Contract} interfészt definiáltam, amelyek közül egy időben hármat használ az alkalmazás. A szolgáltatás funkcionalitását adó távolról hívható metódusok a \code{[ServiceContract]} interfész azon tagfüggvényei lesznek, amelyeket az \code{[OperationContract]} attribútummal megjelölünk. A szoftver struktúrájának szempontjából a definiált szolgáltatások a \code{Rpi.Service} névtérben, a \code{RpiServices} \emph{assembly}-ben lettek deklarálva.\\
\\
Az implementált szolgáltatások közös vonása, hogy mindegyikük tervezéséhez a \emph{singleton} (magyarul egyke) tervezési mintát vettem alapul. Mivel a beágyazott számítógépen a szolgáltatások egyetlen képfeldolgozó folyamat vezérlésére szolgálnak (erre a \emph{use-case} által definiált egyetlen kamera jelenlétéből következtethetünk), így az egyedülálló művelet bizonyos attribútumainak változtatásához is elég egy-egy távolról elérhető szolgáltatás. A \emph{singleton} tervezési minta pontosan azt írja elő, hogy egy osztályt legfeljebb egyszer lehet példányosítani, így egy programban legfeljebb egyetlen adott típusú objektum lehet. Gyakorlati megvalósítása a konstruktor priváttá tételével és egy, az osztály típusával megegyező statikus tagváltozó hozzáadásával érhető el. A statikus adattag referencia az egyetlen példányra, vagy \code{null}. A példányhoz a publikus \code{GetInstance()} tagfüggvény segítségével férhetünk hozzá, amely visszaadja a példányt, amennyiben létezik, ha pedig nem, a privát konstruktorral példányosítja és visszaadja azt, miután a statikus referenciát ráállította. \footnote{A tervezési minta által meghatározott tagváltozók és tagfüggvények a fejezet osztálydiagramjain a \ref{fig:PipelineService_class} ábrán kívül nem kerültek megjelenítésre.} A WCF a \emph{service} hívásakor alapértelmezett esetben minden hívás esetén új példányt hoz létre az azt implementáló osztályból. Ez nem felel meg a fent leírt elvnek, miszerint a szolgáltatásokat reprezentáló osztályok csak egyszer kerülnek példányosításra. Ezért a \emph{service} osztályok definíciójában be kell állítani, hogy minden, kliensek által kezdeményezett hívás ugyanahhoz a példányhoz fusson be a \code{[ServiceBehavior]} attribútum \code{InstanceContextMode} tagváltozójának \emph{Single} értékűre állításával.

\subsection{\code{PipelineService}} \label{subs:pipeline_service}

\paragraph{Feladata} A távoli gépen futó csővezeték konfigurációjára szolgáló programozási felületet definiálja. 

\paragraph{Működése} A \ref{fig:PipelineService_class} ábrán látható módon a szolgáltatás az \code{IPipelineService} \emph{service contract} implementálásával jön létre. Az interfészre, annak definiált tagfüggvényeire és az osztályra is alkalmaztam a \ref{section:servicek} alfejezet bevezetőjében tárgyalt attribútumokat.

\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.1]{PipelineService.pdf}
\centering
\vspace{.2cm}
\caption{\code{PipelineService} szolgáltatás}
\vspace{.5cm}
\label{fig:PipelineService_class}
\end{figure}

Látható, hogy az osztály referenciával rendelkezik egy \code{OperationPipeline} típusú csővezeték objektumra, a kliens által kért változások ezen keresztül jutnak érvényre a képfeldolgozásban.\\
A működés során szükség lehet a feldolgozási sor új művelettel való bővítésére, ez egy \emph{Operation} objektum átküldését jelenti a klienstől a szolgáltatásnak. Szerencsére a \emph{cv4s} keretrendszerben definiált osztály támogatja a sorosítást, így hálózati kapcsolaton keresztül is átküldhető. A szerializáció során a megjelölt tagváltozók XML fájlba íródnak, amely alapján a szolgáltatás példányosítani tudja a kapott paraméterekkel a saját \code{Operation} példányát. Sajnos a \emph{cv4s} keretrendszer nem biztosít beépített eszközt az XML fájl deszerializációjára pusztán a sorosított adat alapján, így saját osztályt implementáltam a feladat elvégzésre, ennek rövid bemutatása a \ref{subs:op_factory} alfejezetben olvasható.\\
A kliens számára elérhető funkciók a következők:
\begin{itemize}
\item \code{AddOperation(string xml, bool repeatable)} Hozzáadja a paraméterként kapott string típusú, XML formátumú műveletet, és a tagváltozó csővezeték \code{OperationList}-jéhez, a szintén paraméterként kapott \emph{bool} paraméter függvényében ismétlődő, vagy egyszer végrehajthatóként.
\item \code{InsertOperation(string xml, bool repeatable, int index = -1)} Az előző metódus funkcionalitását egészíti ki egy index argumentummal, ami beszúrandó művelet helyét jelöli ki a listában. Ha az index negatív értékű, vagy nagyobb, mint a listaelemek száma, akkor a végére szúródik be. Valójában az \code{AddOperation} metódus is ezzel van implementálva, csak az olvashatóság kedvéért került bele redundáns módon a két tagfüggvény.
\item \code{RemoveOperation(int index=-1)} Eltávolítja a megadott indexű műveletet a konténerből.
\item \code{UpdatePipeline(List<string> operationXmls)} A műveleteket tartalmazó teljes listát a paraméterként kapott műveletekkel tölti fel azok példányosítása után.
\item \code{uint Fps(int fps)} Megpróbálja beállítani a feldolgozási sebességet a kapott paraméterre, és visszaadja a valójában beállított értéket a kliensnek.
\item \code{Ping()} a metódus a szolgáltatás kliens oldali elérhetőségének vizsgálatára szolgál, megfelelő kapcsolat esetén a \emph{service} verzióját adja vissza.
\end{itemize}

\paragraph{Konfiguráció}

Az elkészült szolgáltatáshoz tartozó végpontok konfigurációját adminisztratív módon definiáltam a Visual Studio projekthez tartozó \code{Web.config} fájlban. A WCF által biztosított \code{BasicHttpBinding} kötést használtam a HTTP protokollt használó végponthoz, az időkorlátok (fogadási, küldési és a kapcsolat lezáráshoz tartozó) értékeinek 10 másodpercre való változtatásával. A \emph{service} elérhető még TCP protokollal is a \code{NetTcpBinding} osztályt példányosítva, valamint metaadat cseréhez definiáltam még egy MEX végpontot is \code{MexHttpBinding}-gal. A fejlesztés során a \code{localhost} címet használtam a szolgáltatás elérésre, amely így a következő címeken érhető el:

\begin{mdframed}[backgroundcolor=gray!20]
\begin{normalsize}
\begin{lstlisting}[language=XML]
http://127.0.0.1:16480/OperationPipeline/
net.tcp://127.0.0.1:16480/OperationPipeline/
\end{lstlisting}
\end{normalsize}
\end{mdframed}

\subsection{\code{OperationFactory}} \label{subs:op_factory}

Mivel a \emph{cv4s} keretrendszer nem támogatja a képfeldolgozó műveletek deszerializációját pusztán XML fájl alapján, szükség volt egy erre alkalmas osztály implementálására. Az \code{OperationFactory} osztály a \emph{factory} tervezési mintát megvalósítva példányosít \code{Operation} objektumokat azok sorosított XML reprezentációja alapján. Az \ref{fig:OperationFactory_class} ábrán látható, hogy új művelet objektum az osztály \code{GetOperation} metódusának hívásával példányosítható, paraméterként az XML reprezentációt adva.

\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.1]{OperationFactory_class.pdf}
\centering
\vspace{.2cm}
\caption{\code{OperationFactory} osztálydiagramja}
\vspace{.5cm}
\label{fig:OperationFactory_class}
\end{figure}

A kapott szöveges adat fejlécében megtalálható a létrehozandó objektum típusa, amelyet a .NET keretrendszer \code{XmlDocument} osztályának segítségével határoz meg. Az osztálynév ismeretében a \code{GetOperation} metódus egy \code{switch-case} szerkezettel kiválasztja, pontosan milyen típusparaméterrel kell meghívni a \emph{cv4s framework} \code{XmlSerializationHelper} objektumának deszerializáló tagfüggvényét és visszaadja az eredményül kapott objektumot. Ha az osztálynevet nem ismeri az \code{OperationFactory}, a képfeldolgozó műveleteket tartalmazó \emph{assembly} megfelelő típusát példányosítja a .NET keretrendszer \code{Activator} osztályával, azonban ilyenkor a kapott paramétereket nem veszi figyelembe, az adott \code{Operation} típus alapértelmezett konstruktorát hívja meg.

\subsubsection{Tesztek}

A kommunikációt végző komponensek közül egyedül ehhez az osztályhoz készült \emph{unit test}, lévén a többi valamilyen webes szolgáltatást valósít meg, így a gyakorlatban komponens tesztet érdemesebb rájuk készíteni.\\
A teszt menete viszonylag egyszerű, a  

\subsection{\code{RpiLogService}} \label{subs:rpi_log_service}
\paragraph{Feladata} A végrehajtó eszköz távoli felügyeletét teszi lehető a feldolgozás során keletkező üzenetek továbbításával. A funkciót ellátó osztály megvalósítja a \emph{cv4s} \code{ILog} interfészét, így rugalmasságot biztosít a felhasználónak , ha esetleg nem távoli elérhetőséget lehetővé tevő alkalmazásban szeretné az \code{OperationPipeline} modult használni. Az interfész különböző szintű (\code{verbose}, \code{debug}, \code{information}, \code{warning}, \code{error}) üzenetek továbbítását írja elő a \ref{subs:logging} alfejezetben leírt funkcionalitás megvalósítására.
\paragraph{Működése} A webes szolgáltatások \emph{service-client} architektúrájában a kliens kérésére küld adatot a \emph{service}, viszont jelen esetben fordított irányú kommunikációra van szükség, hiszen a kliens nem tudja mikor születik új naplóbejegyzés a túloldalon. A WCF keretrendszer alkalmazásával lehetséges úgynevezett duplex kapcsolat kialakítása, amellyel a \emph{service} is meg tudja hívni a csatlakozott kliens elérhető metódusait, ez az úgynevezett \emph{duplex binding}. Ilyenkor két ellentétes irányú HTTP kapcsolat jön létre a komponensek között. A keretrendszer \code{WsDualHttpBinding} objektumát használva meglehetősen egyszerűen használható ilyen kapcsolat. A szoftveres megvalósításhoz a \emph{contract}-ot a \ref{section:servicek} alfejezet bevezetőjében leírtaktól eltérően kell implementálni. A szolgáltatásnak ugyanis szüksége van a kliens oldalon hívható metódusok ismeretére egy úgynevezett \emph{callback contract} által. Ez a szerződés szintén egy C\# interfész, amelynek tagfüggvényeit a \code{[ServiceMethod]} attribútummal látjuk el, és a szolgáltatás \code{[OperationContract]} attribútumának paraméterül adjuk. Az implementált osztályok és interfészek viszonyát a \ref{fig:RpiLogService_class} ábra szemlélteti.\\

\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.1]{RpiLogService.pdf}
\centering
\vspace{.2cm}
\caption{\code{RpiLogService} osztálydiagramja}
\vspace{.5cm}
\label{fig:RpiLogService_class}
\end{figure}

A kliens oldali \emph{callback contract} (\code{IRpiLogServiceCallback}) az \code{ILog} interfész tagfüggvényeit fedi fel a szolgáltatás számára, a beérkező naplóüzenetek hatására ezeket hívja meg a \emph{service}. A kliens oldalnak a szolgáltatás igénybevételéhez rendelkeznie kell egy olyan objektummal, amely a \emph{callback} függvényeket implementálja.\\
A \emph{service} oldalon a naplózást a \code{RpiLogService} típusú objektum látja el. Ez a már említett \emph{singleton} tervezési mintával készült, és a \emph{service contract} mellett implementálja az \code{ILog} interfészt is, hogy többek között az \emph{OperationPipeline} tagváltozójaként is használható legyen. Az ősosztály biztosítja a lokális konzolra történő naplózást, amely ugyan szintén implementálja az \code{ILog} interfészt, azonban a C\# szabályai szerint a leszármazott osztályban szintén szükséges megadni a viszonyt. \cite{cs-in-a-nutshell}

A naplózási szolgáltatásra a távoli eszköz \code{Subscribe} metódusával iratkozhatnak fel. A feliratkozás során a \code{Channel} objektumot, amin keresztül a hívás érkezett, az \code{RpiLogService} elmenti egy konkurens hozzáférést biztosító asszociatív tömbbe, amelyet egyedi 128 byte-os azonosítóval tud megcímezni; ez az azonosító minden új kliens feliratkozásakor a \code{Guid} osztály segítségével generálódik. Azért van szükség a versenyhelyzetek elkerülésére, mert a \emph{service} tetszőleges számú klienst szolgálhat ki adott időpillanatban és elméletileg előfordulhat, hogy két kliens egyszerre akar feliratkozni a szolgáltatásra. Amennyiben egy kliens nem akar több naplóüzenetet fogadni, az \code{Unsubscribe} függvény WCF-en keresztül való hívásával iratkozhat le; ekkor az őt azonosító bejegyzést a \emph{service} törli. Duplex kapcsolat esetén szolgáltatás nem tudja automatikusan detektálni, ha a kliens leiratkozik \cite{wcf-doc}, ezért ha adott csatornán a konfigurációs fájlban megadott ideig nem kap választ, törli a klienst az ismert kapcsolatok közül.\\
A működés során a bejövő naplóbejegyzések hatására először az ősosztály megfelelő naplózó metódusa hívódik, hogy a lokális konzolon is megjelenjen az üzent, majd az \code{InvokeClientCallback()} függvényhívás az ismert kliensek \code{Channel} objektumára továbbítja a naplóbejegyzést, kiváltva a kliens oldalon a megfelelő \emph{callback} függvényt. Az ábrán csak mellékes megjegyzésként szereplő \code{RpiClientLogger} a kliens oldalon naplózást végző osztály, részletes leírása a \ref{subs:client_log} bekezdésben található részletesen.

\paragraph{Konfiguráció} A HTTP protokoll felett történő kommunikációra a WCF már említett \code{WsDualHttpBinding} kötést használtam. A \code{PipelineService} modul beállításaival ellentétben itt sajnos nem volt lehetőség TCP kapcsolat kialakítására, mert a WCF nem biztosít ehhez, megfelelő \emph{binding} objektumot az előre definiáltak közül. Természetesen implementálni lehetne megfelelő tulajdonságokkal rendelkező osztályt, ami a duplex kapcsolatot kezelni tudná, azonban egyszerűbb megoldásnak tűnt a következő bekezdésben bemutatott szolgáltatás létrehozása.

\subsection{\code{PollLogService}}
\paragraph{Feladata} Az alkalmazás fejlesztése során a működést nagyrészt Windows operációs rendszeren vizsgáltam a beágyazott eszközön csak viszonylag ritkán futtatva a programot a \ref{subs:fejlesztes_menete} alfejezetben leírtak szerint. Emiatt azonban a platformtól való függőségek csak egy-egy nagyobb részlet elkészülte után derültek ki, így a figyelmemet elkerülte, hogy a \ref{subs:rpi_log_service} alfejezetben bemutatott \code{WsDualHttpBinding} csak Windows környezetben működik, a Raspberry/Raspbian platformon nem. A probléma megoldására olyan naplózó komponenst kellett tervezni, ami a megszokott, egyirányú metódushívással képes az üzeneteket a klienseknek továbbítani, így született meg a \code{PollLogService} osztály ami \emph{polling} módszerrel periodikusan kéri le az üzeneteket a \emph{service}-től. A két megvalósított naplózó szolgáltatás közül egyszerre csak az egyiket lehet használni, mert az objektumok, amelyek a naplóbejegyzéseket készítik, csak egyetlen példányra tartalmaznak referenciát a definíciójukban. Így még a szolgáltatások közzé tétele előtt kell kiválasztani a naplózó szolgáltatás típusát a \ref{subs:cli} bekezdésben leírtak szerint.

\begin{figure}[h]
\vspace{.5cm}
\includegraphics[width=1.0\textwidth]{PollLogService.pdf}
\centering
\vspace{.2cm}
\caption{\code{PollLogService} osztálydiagramja}
\vspace{.5cm}
\label{fig:PollLogService_class}
\end{figure}

\paragraph{Működése} A naplózó szolgáltatás a \code{RpiLogService}-hez hasonlóan a \emph{publish-subscribe} sémát követi, azaz a kliensek a feliratkozás után értesülnek a bejegyzésekről. Itt azért van szükség a feliratkozásra, mert a \emph{service} a kliensek számára külön tárolókban gyűjti az üzeneteket, és mikor a kliens lekéri, egyszerre elküldi az addig összegyűlt bejegyzéseket, majd üríti a tárolót. Ehhez a funkcióhoz szükség volt egy konténer osztály implementálásra, ez a \code{LogQueue}, amely a különböző szintű üzeneteket egy-egy várakozási sorban tárolja, a \emph{composition over inheritance} elvet szem előtt tartva, és konkurens hozzáférés ellen is védelmet nyújt a konzisztens adatállapot fenntartása érdekében. Versenyhelyzet úgy alakulhat ki a szálak között, hogy több szálon futó objektumok írnak a naplózó objektumba, így garantálni kell annak elkerülését a standard .NET típusuk segítségével. A kliens feliratkozásakor a \ref{subs:rpi_log_service} bekezdésben leírtakkal azonos módon új azonosítót kap, és bekerül az ismert kliensek közé. Amikor a kliens lekéri valamelyik naplószinthez tartozó bejegyzéseket, a hozzá tartozó \code{LogQueue} példány megfelelő konténerét kapja meg, ami a \emph{service} oldalon ürítésre kerül.

\paragraph{Konfiguráció} Lévén a szolgáltatás a \emph{request-reply} kommunikációs sémát követi lehetőség volt a \ref{subs:pipeline_service} alfejezetben leírt konfiguráció használatára. A HTTP végpont így a \code{BasicHttpBinding} objektumot használja. Az \code{RpiLogService}-től eltérő módon TCP végpontot is képes nyitni, amelyet a \code{NetTcpBinding} osztály példánya kezel.

\begin{figure}[h]
\centering
\begin{minipage}{1\textwidth}
\begin{mdframed}[backgroundcolor=gray!20]
\begin{normalsize}
\begin{lstlisting}[language=XML]
http://127.0.0.1:16480/PollLog/
net.tcp://127.0.0.1:16480/PollLog/
\end{lstlisting}
\end{normalsize}
\end{mdframed}
\end{minipage}
\caption{\code{PollLogService} szolgáltatás elérése a lokális gépen}
\end{figure}

\subsection{\code{SnapshotService}}
\paragraph{Feladata}
A képfeldolgozó csővezeték működésének ellenőrzésre szolgál a folyamatból kiragadott képek lekérdezésével. A felhasználó így megvizsgálhatja, hogy az adott konfiguráció mennyire felel meg céljainak. 

\paragraph{Működése}
A szolgáltatáshoz tartozó \emph{service contract} mindössze egyetlen metódust tartalmaz, a képek átküldésére alkalmas \code{GetSnapshot()} függvényt. A függvény fejléce a következő:
\begin{mdframed}[backgroundcolor=gray!20]
\begin{small}
\begin{lstlisting}[language=java]
byte[] GetSnapshot(Cv2.ImreadModes mode);
\end{lstlisting}
\end{small}
\end{mdframed}

Képek sorosítására igyekeztem egy segédosztályt létrehozni, amely a WCF \emph{data contract} nevű, osztályok továbbítására vonatkozó egyezményét használja. A \code{MatSerializationHelper} osztály feladata az lett volna, hogy elfedje a sorosítási és visszaalakítási műveleteket, azonban valamiért a modul használatával nem sikerült adatot átküldeni az eszközök között. Így végül a képet a kliens \code{byte[]} formátumban kapja és az OpenCvSharp használatával alakítja vissza képi objektummá.

\paragraph{Konfiguráció} 
A szolgáltatást valójában csak a konfigurációja miatt kellett a \code{PipelineService}-től külön osztályban implementálni. Az ok az adat eltérő típusa, ugyanis a konfigurációval kapcsolatos üzenetek mind szöveg alapúak, digitális kép esetében azonban a szöveg alapú adattovábbítás korántsem a legjobb választás. További eltérés az adatmennyiség, ami az időkorlátok konfigurációját befolyásolja. A WCF keretrendszer bináris adatok továbbítására támogatja a W3C konzorcium MTOM (\emph{message transmission optimization mechanism}) nevű kódolását, így a képek küldésére ezt alkalmaztam. A már említett időkorlátokat a szöveg alapú üzenetektől eltérően 30 másodpercre állítottam, valójában heurisztikus alapon, mivel valódi alkalmazásban a hálózati kapcsolat sebessége és a kamera felbontása határozza meg az értéket.

\section{Host alkalmazás} \label{section:RpiRemoteHost}

A távoli eszközön futó program egy egyszerű \code{Console Application}, amelynek feladata a parancssorból kapott paraméterek \ref{subs:cli} bekezdésnek megfelelő feldolgozása, és egy \code{RpiRemoteHost} osztály példányosítása ezen paraméterekkel. Az \code{RpiRemoteHost} a \ref{chapter:kepfeldolgozo} és \ref{chapter:kommunikacio} fejezet korábbi részeiben leírt funkcionalitások alkalmazásba való aggregálását végzi. Ez az osztály felelős az erőforrások inicializálásért, a csővezeték és a kamera olvasó osztály felügyeletéért, valamint a végpontok kezeléséért.\\
\\
A megvalósított osztály a három egyszerre elérhetővé tett végponthoz tartozó \code{ServiceHost} objektumokra tartalmaz referenciát. Ez az osztály a WCF keretrendszer része, feladata, hogy az elkészült szolgáltatásokat elérhetővé tegye a konfigurált címeken. A konstruktora több lehetőséget is ad a példányosításra, az \code{RpiRemoteHost} osztály minden végpont esetében a \emph{service} példányát adja át a \emph{host}-nak. Erre azért van szükség, mert a szolgáltatásokat alapesetben a \emph{host} objektum példányosítja, azonban azokat a megnyitásuk előtt konfigurálni kell, a következő módon:
\begin{itemize}
\item A naplózó szolgáltatások példányosítása azért szükséges, mert ezt az objektumot használja az összes \emph{service} oldali komponens, így a rá mutató referenciára mindenképp szükség van.
\item \code{OperationService}: a \code{OperationPipeline}, \code{CameraReader} és \code{Log} tagváltozók inicializálása a kapott paraméterek alapján.
\item \code{SnapshotService}: naplózó tagváltozó beállítása.
\end{itemize}

Az \code{RpiRemoteHost} inicializálásakor megkapja a parancssorról kapott paramétereket és azok alapján hozza létre szolgáltatásokat. Az \code{Open()} metódus publikálja a létrehozott műveleteket \emph{service}-eket, a \code{Close()} pedig bezárja azokat.

\subsection{Parancssori interfész} \label{subs:cli}

Mivel az eszköz a felhasználói eset szerint nehezen hozzáférhető helyen található, gondoskodni kellett a távirányítható alkalmazás távolról, konfigurálható paraméterekkel történő indításáról is. Előfordulhat ugyanis, hogy a program olyan állapotba kerül, amelyből már csak az újraindításával lehet visszatérni az elvárt működéshez. Ehhez készítettem egy, a GNU/Linux operációs rendszeren megszokott paraméterstruktúrával rendelkező \emph{CLI}-t (\emph{command line interface}-t). A leírt paraméterekkel összeállított parancsot távoli gépről \code{ssh} paranccsal adhatjuk ki az eszközön. A szabványos .NET Framework-ben sajnos nincs hasonló parancssori támogatást nyújtó osztálykönyvtár, így a \code{Mono.Options}  nevű csomagot használtam -- amely a Mono keretrendszer része, és ennek megfelelően nyílt forráskódú --, ennek segítségével egyszerűen elkészíthető készíthető következő paraméterekkel rendelkező interfész:

\begin{figure}[h]
\centering
\begin{minipage}{1\textwidth}
\begin{mdframed}[backgroundcolor=gray!20]
\begin{scriptsize}
\begin{lstlisting}[language=xml]
  -l, --location=VALUE       Path to the video file to play.
  -p, --poll                 Use the poll log service. If false, duplex binding is
  			     required.
  -v, --verbosity=VALUE      Use this verbosity level.
  -f, --fps=VALUE            Framerate for the camera reader.
  -w, --winPort=VALUE		 Use this value to read from camera port on Windows
  -h, --help                 Show this message and exit
\end{lstlisting}
\end{scriptsize}
\end{mdframed}
\end{minipage}
\caption{CLI segítség menüje} \label{figure:cli_help}
\end{figure}

Az "-l" kapcsolóval a fájl helyét lehet megadni, ahol a kiolvasandó videostream található, ez lehet Linuxon eszköz helye, vagy egy létező videofájl a fájlrendszerben.
A "-w" argumentummal megadott szám annak az csatlakoztatott kamera eszköznek a számát jeli ki, amelyből a kamera adatokat olvassuk ki Windows rendszeren, ezt az opciót akkor adjuk meg, ha a fájl helyét nem jelöltük meg a -l kapcsolóval.
A "-p" paraméterrel azt szabályozhatjuk, hogy a \emph{service}-ünk naplóüzenet szolgáltatása kétirányú kapcsolatot nyisson vagy a kliens által lekérdezendő legyen.
A "-v" kapcsoló mellé szükséges egy pozitív egész szám, ami a \emph{service} oldali naplózás szintjét állítja be. Alapesetben érdemes az alapértelmezett "\emph{verbose}" szinten hagyni, és a kliens oldalon kiszűrni a szükségtelen üzeneteket. 
Beállítható még továbbá a csővezeték indításakor használt kiolvasási sebesség, ami képkocka/másodperc dimenzióval értendő.
A program paramétereiről összefoglaló információt a "-h" kapcsolóval kérhetünk, ekkor a \ref{figure:cli_help} ábrán látható üzenetet kapjuk.

\section{Fejlesztés menete} \label{subs:fejlesztes_menete}

A fejlesztés során nehézséget jelentett, hogy a kódot Visual Studio fejlesztőkörnyezetben írtam a kódot, azonban egy másik, eltérő operációs rendszerű és architektúrájú eszközön kellett tesztelni. Emiatt a fejlesztés során a programot a lokális, Windows rendszeren futtattam, az eszközön viszonylag ritkán próbáltam ki. A szolgáltatások mindegyike a \code{16480} számú porton elérhető, azonban a Windows nem engedélyezi a nem adminisztrátori jogokkal futtatott programok számára -- néhány szabványos kivételével -- a portok lefoglalását. Így az alkalmazást vagy adminisztrátorként kell futtatni (ami meglehetősen körülményes módszer), vagy a hálózati interfész használatát engedélyezzük a felhasználói programok számára. Ehhez a Windows parancssorában adminisztrátorként a következő parancsot kell kiadni, a \code{user} paraméternek pedig azt felhasználót megadni, akinek a port használatát engedélyezzük.

\begin{mdframed}[backgroundcolor=gray!20]
\begin{small}
\begin{lstlisting}[language=XML]
netsh http add urlacl url="http://+:16480/" user=...
\end{lstlisting}
\end{small}
\end{mdframed}

A Raspberry Pi használatához a \emph{cygwin} nevű, Linux terminált emuláló programot használtam, ezen keresztül \code{ssh}-val jelentkeztem be az eszközre, így a kiadott parancsok a távoli számítógépen hajtódtak végre. Az eszközön való tesztelést nehezítette, hogy a Visual Studio-val lefordított binárisokat minden futtatás előtt az eszközre kellett másolni. A másolást szintén a \emph{cygwin} terminálból, az scp paranccsal végeztem, majd az eszközre való bejelentkezés után futtattam a programot. A képfeldolgozó műveletek eredményességéhez szükséges a grafikus felhasználói felület is, ehhez a \emph{VNC Viewer} nevű alkalmazást használtam, ami szintén \code{ssh} kapcsolaton keresztül jeleníti meg az eszköz GUI-ját. Ez a folyamat azonban  kellően időigényes ahhoz, hogy a fejlesztés során a teszteléshez más módszer után nézzek. \\
A program manuális teszteléséhez szükséges idő csökkentésére először létrehoztam egy virtuális asztali Linux környezetet, lefordítva és telepítve a \ref{chapter:architektura} fejezetben leírt csomagokat. A virtuális gép nyilvánvalóan eltér a beágyazott rendszertől, de a debian disztribúciót használva a különbség nem túl nagy ahhoz, hogy fejlesztés közben használható legyen, időnként természetesen a Raspberry Pi-n is ellenőrizve a program működését. Ebben az esetben a binárisok másolgatása sem szükséges a futtatási környezetek között, ha a mappát, amelybe a fordításkor a fájlok kerülnek, megosztjuk a virtuális gép számára.\\
\\
Sajnos a virtuális gépet futtatni meglehetősen erőforrás-igényes és az általa biztosított szolgáltatások jelentős részére nem is volt szükségem. A \ref{subs:docker_bevezeto} bevezető bekezdésben már említett \emph{Docker} pontosan erre a problémára kínál megoldást, így létrehoztam egy, a \emph{service} futtatásához szükséges szoftvereket tartalmazó \emph{Docker} \code{image}-et, a \ref{subs:docker} pontban kifejtett módon. A \emph{container} használatával már viszonylag egyszerűen lehetett a szolgáltatást GNU/Linux rendszeren kipróbálni.

\subsection{Docker} \label{subs:docker}

A Docker szolgáltatás \emph{lightweight}, azaz kis erőforrás igényű, szeparált és hordozható futtatási környezetet biztosít az alkalmazások számára. A host rendszertől elkülönített környezetet a Docker terminológiája \emph{container}-nek nevezi, ebbe "csomagolva" az alkalmazás függetlenül futhat. Működése során az eredetileg GNU/Linux rendszerre készült program az operációs rendszer csomagjait is használja, nem virtualizálja a hardvert. Windows alatt is futtathatunk Linux konténereket, ezekhez a program egy kis erőforrás igényű virtuális \emph{Alpine} Linux rendszert indít el. 
\\
 A \emph{container}-ek úgynevezett \emph{image} fájlokból indíthatóak a program parancssori interfészével, ezek hasonlóak a virtuális gépeknél használt image-ekhez, a futási környezet tulajdonságait tartalmazzák. Egy \emph{image}-ből tetszőleges számú független \emph{container} indítható különböző paraméterekkel. Image fájlokat a Docker által üzemeltetett \code{hub.docker.com} címen elérhető szolgáltatásról tölthetünk le, vagy elkészíthetjük a személyre szabott image-ünket egy \emph{Dockerfile} alapján. A futtatókörnyezet viszonylag különleges csomagigényei miatt a hordózhatóságot szem előtt tartva az utóbbi megoldás mellett döntöttem.\\
A \emph{Dockerfile} egy szöveges fájl, mely soronként tartalmazza a környezet létrehozásához szükséges utasításokat. A parancssorban a \code{docker build} parancs kiadásával készíthetünk image-et a Dockerfile-ból. \cite{docker-doc}

\begin{mdframed}[backgroundcolor=gray!20]
\begin{small}
\begin{lstlisting}[language=XML]
docker build -t cv4s_rpi -f .\rpi-docker-image.Dockerfile .
\end{lstlisting}
\end{small}
\end{mdframed}

A \code{-t} kapcsolóval a generált image címkéjét, a \code{-f}-fel a Dockerfile helyét adjuk meg. Lehetőség van egy mappa elérési útjának megadására is, amelyben található fájlokhoz a fordítás során hozzáfér a program. Az image készítése közben a Dockerfile minden sora új átmeneti képfájlt készít, és a következő lépés ezt alapul véve, mintegy új réteget hozzáadva készíti el saját átmeneti image-ét. Ez a megoldás a hosszú fordítási idejű képfájlok esetén azért előnyös, mert a folyamatbeli hiba esetén nem szükséges az elejéről kezdeni a \emph{build} folyamatot, az a legutolsó elkészült átmeneti példánytól tud folytatódni. Hátrányos lehet a sok lépést tartalmazó Dockerfile-ok fordítása során, hogy sok átmeneti képfájl keletkezik, ami nagy lemezterületet foglal a háttértárolón, Dockerfile-ok írása során érdemes a kiadott parancsokat \emph{shell script} formájában futtatni. \cite{docker-doc}\\
Az általam elkészített Dockerfájl is csoportosítva hajtja végre szükséges lépéseket a fordítás során, a teljes Dockerfile  a \ref{fig:docker_commands} ábrán látható.

\begin{figure}[h]
\centering
\begin{minipage}{1\textwidth}
\begin{mdframed}[backgroundcolor=gray!20]
\begin{small}
\begin{lstlisting}[language=XML]
# Latest debian release is the base image
FROM debian

# Root permission is needed inside the container
USER root
# Expose this port to the world
EXPOSE 16480
# Copy shell scripts which will install necessary components
COPY install_dependencies.sh install_opencv.sh \
install_opencvsharp.sh install_mono.sh misc.sh \
update_host.sh /shared/

# Run shell scripts
RUN /bin/bash -c "/shared/install_dependencies.sh"
RUN /bin/bash -c "/shared/install_opencv.sh"
RUN /bin/bash -c "/shared/install_opencvsharp.sh"
RUN /bin/bash -c "/shared/install_mono.sh"
RUN /bin/bash -c "/shared/misc.sh"

# Run bash
CMD "/bin/bash"
\end{lstlisting}
\end{small}
\end{mdframed}
\end{minipage}
\caption{\code{Dockerfile}} \label{fig:docker_commands}
\end{figure}

A fordítás során a legfrissebb \emph{Debian} image-ből kiindulva telepítjük a szükséges csomagokat. A létrejövő \emph{image}-en belül \code{root} jogosultsággal fogunk rendelkezni, ez a telepítést is leegyszerűsíti, mert nem kell kiadni a \code{sudo} parancsot a csomagkezelő műveletek előtt. Ezután az 16480-as portot elérhetővé teszi a host gép számára a \code{EXPOSE} utasítással, majd a \code{COPY} paranccsal a fordító a munkakönyvtárban található telepítő scripteket bemásolja a képfájlba. A fájlok a függelék \ref{rpi-build-script} pontjában található telepítő utasításokat tartalmazzák logikai egységekre felbontva. Ezen kívül tartalmaz még egy \code{update\_host.sh} nevű scriptfájlt is, amely arra szolgál, hogy a tesztelés során a hostgépen lefordított binárisokat a kívánt munkamappába másolja, hogy ne az eredeti helyen módosítsuk a fájlokat.\\
\\
A Docker konténer a következő paranccsal készíthető el az \emph{image}-ből:

\begin{mdframed}[backgroundcolor=gray!20]
\begin{small}
\begin{lstlisting}[language=XML]
docker run -ti --name rpi_host -v path/to/binaries\:/mnt/
 -p 16480:16480 cv4s_rpi
\end{lstlisting}
\end{small}
\end{mdframed}

A "\code{-ti}" kapcsoló kombinációval a konténer standard IO fájljait a egy pszeudo terminálra irányítja át, így a bemeneti parancsokat egy Linux konzolról tudjuk átadni és az utasítás kimeneti is itt fognak megjelenni, mintha egy valódi Linux eszközzel kommunikálnánk. \\
A \code{--name} argumentum paramétere lesz a konténer neve, amivel a használata során hivatkozhatunk rá.\\
Lehetőség van a host számítógép fájlrendszerét megosztani a konténerrel, így az ott tárolt fájlok elérhetők a leválasztott környezeteben. A webes szolgáltatás futtatásához szükség van a legfrissebb lefordított binárisokra, melyek elérési útja a \code{path/to/binaries/}. A konténeren belül ezeket a \code{/mnt/} könyvtárban találjuk.\\
A fenti beállításokon kívül szükség van még a \code{-p} kapcsolóval a konténer és a host portjainak összerendelésére, hogy a gazda számítógép hozzáférjen a \emph{service}-hez. A \code{run} parancs utolsó paramétere a Docker \emph{image} neve, amelyből a \emph{container} készül.\\
\\
A tárolón belül a \emph{service} alkalmazás a \code{mono}-val futtatható, a \ref{subs:cli} bekezdés szerinti paraméterezéssel.