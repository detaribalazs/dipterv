\chapter{Kommunikáció} \label{chapter:kommunikacio}
\section{Windows Communication Foundation}
Az eszköz távirányíthatóságát a .NET Framework \emph{Windows Communication Foundation} (WCF) nevű, szolgáltatás-orientált keretrendszerének segítségével oldottam meg. A rugalmasságot szem előtt tartva igyekeztem teljesen elkülöníteni a távoli vezérelhetőséget, illetve a \ref{chapter:kepfeldolgozo} képfeldolgozási funkciókat biztosító osztályokat.\\

Az elkészített szoftverkomponens bemutatása előtt pár szó a WCF-ről, illetve a mögötte lévő szoftvertervezési filozófiáról. A \ref{ssection:wcf_intro} számú bevezetőben leírt szolgáltatás-orientált szemlélet szerint készült C\# nyelven írt alkalmazások támogatására a Microsoft a WCF keretrendszert hozta létre. A keretrendszer menedzselt futási környezetet biztosít a szolgáltatások számára, amelyen keresztül azok CLR típusokat tehetnek közzé, illetve a fogadott adatot CLR típusként reprezentálhatják. Az alkalmazás komponensei nem igénylik a közös operációs rendszert, programozási nyelvet, de még azt sem, hogy egy számítógépen fussanak, elegendő a megfelelően konfigurált adatkapcsolat illetve a programozási felület (\emph{API}) ismerete. A WCF terminológiája az szoftver-egységet \emph{service}-nek (magyarul szolgáltatásnak) nevezi, és a szolgáltatás-orientált több ilyen egységet aggregál, miközben ezen egységek függőségei minimálisak. A \emph{service} ugyanis nem más mint funkcionalitások összessége, amit a komponens elérhetővé tesz a többi szolgáltatás számára, leegyszerűsítve távolról hívható függvény gyűjtemények, melyek egymástól függetlenül karban tarthatók (hasonlóan az objektumorientált szemlélet által bevezetett osztályokhoz, azonban kisebb mértékű csatolással).\\

Az így létrejövő struktúrában a szolgáltatások mellett megjelennek az őket igénybe vevő kliensek (\emph{client}), amelyek gyakorlatilag bármilyen formát ölthetnek --  Windows Forms, ASP.NET alkalmazás vagy a mi esetünkben WPF (\ref{chapter:kliens} fejezet). A \emph{service-client} architektúrában a komponenseknek egymásról csak korlátozottan van információjuk és aszinkron módon üzenetekkel kommunikálnak. A kliensek a szolgáltatások funkcionalitását és jellemzően a WCF által biztosított \emph{metaadat cserén} keresztül ismerik meg. A metaadat valamilyen technológia-független módon kerül közzétételre, és tartalmazza az adott szolgáltatás által nyújtott funkcionalitásokat, valamint a kommunikáció lehetséges módjait. \\

Fontos megjegyezni -- és erre a megvalósított rendszernél is ki fogok térni--, hogy a kliens nem közvetlenül a szolgáltatással kommunikál, hanem egy proxy-objektummal, amely ugyanazokkal a funkcionalitásokkal rendelkezik, mint a \emph{service} és ezen felül memória-kezelő tulajdonságai is vannak. \cite{wcf-programming}
\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.25]{wcf_abc.pdf}
\centering
\vspace{.2cm}
\caption{WCF végpont}
\vspace{.5cm}
\label{fig:wcf_abc}
\end{figure}

Egy szolgáltatás három dolog azonosít egyértelműen: 
\begin{itemize}
\setlength\itemsep{.25em}
\item \emph{Address}
\item \emph{Binding}
\item \emph{Contract}
\end{itemize}
Ezek együttesen egy \emph{végpontot} (\emph{endpoint}-ot) definiálnak a \ref{fig:wcf_abc} ábrán látható módon.
\paragraph{Address} Minden szolgáltatáshoz tartoznia kell egy egyedi címnek, amely két fontos részletében hordoz információt a kliens számára, méghozzá a meghatározza a \emph{service} helyét (a lokális számítógépen vagy a hálózaton), illetve a kommunikáció módját az alkalmazott protokoll által. A cím mindig a következő formában írható fel:

\begin{mdframed}[backgroundcolor=gray!20]
\begin{scriptsize}
\begin{lstlisting}[language=bash]
[transport]://[machine or domain][:optional port]/[optional URI]
\end{lstlisting}
\end{scriptsize}
\end{mdframed}

A WCF által támogatott, általam használt kommunikációs sémák a HTTP/HTTPS és a TCP. (Ha lokális gépen futó kliens számára szeretnénk szolgáltatást \emph{host}-olni, az IPC (\emph{inter-process communication}), MSMQ (\emph{Microsoft Message Queue}, illetve a Service Bus kommunikációs protokollok valamelyike lehet a jó megoldás.)
\paragraph{Binding}
\paragraph{Contract} Platformfüggetlen \emph{szerződésként} írja le a szolgáltatás képességeit a kliens számára. Az objektumorientált szemléletben használt interfészekkel állítható párhuzamba -- megvalósítása objektumorientált nyelven (esetünkben C\#) gyakorlatilag is interfészekkel történik. A WCF négyféle \emph{contract} típust definiál, melyek a 
\begin{itemize}
\setlength\itemsep{.1em}
\item \emph{Service contract}
\item \emph{Data contract}
\item \emph{Fault contract}
\item \emph{Message contract}.
\end{itemize}
Ezek közül a lehetőségek közül a diplomamunkámban két típust, a \emph{service} és \emph{data contract}-ot használtam fel.


A végpontot azonosító három összetevő egyenként is számos eltérő beállítási lehetőséget nyújt, azonban összességében nézve szinte teljeskörűen az alkalmazásra szabható konfigurációt kapunk. A legtöbb alkalmazásban nincs szükség minden paraméter részletekbe menő beállítására, erre a keretrendszer előre definiált megoldásokat ad a leggyakoribb problémákra mindhárom komponens esetén. \\
\\
Fontos megjegyezni, hogy minden \emph{service}-hez tartoznia kell legalább egy -- de akár több -- \emph{endpoint}-nak. A szolgáltatást futtató \emph{host} ezeket a végpontokat teszi elérhetővé a kliensek számára a már említett metaadat cserén keresztül.

A WCF architektúrában a Raspberry Pi-n futó képfeldolgozó alkalmazás a \textit{service} szerepét tölti be, a felügyelő feladatot ellátó, asztali gépen futó alkalmazás pedig kliensként veszi igénybe annak szolgáltatásait.\\
Az alább bemutatott szolgáltatások a egy-egy \code{ServiceContract} attribútummal ellátott interfész implementálásával, illetve konfigurációs fájl hozzáadásával válnak távolról elérhető szolgáltatásokká.

\section{Megvalósított \emph{service}-ek és konfigurációjuk}
\subsection{PipelineService}

\paragraph{Szolgáltatások}
A képfeldolgozó modul távoli vezérelhetőségét a \code{PipelineService} osztály biztosítja azáltal, hogy megvalósítja a a \code{IPipelineService} \textit{szerződését}. Ezáltal a következő műveletek lesznek elérhetőek interneten keresztül:
\begin{itemize}
\item művelet hozzáfűzése a végrehajtási lánc végéhez
\item művelet beszúrása megadott pozícióba a műveleti listába
\item művelet eltávolítása a műveletek közül
\item műveleti sor teljes frissítése egy lista alapján
\item képernyőkép lekérése az utolsó feldolgozott képkockával
\end{itemize}

A kliens oldalon konfigurált képfeldolgozási művelet \code{xml} formátummá konvertálódik a küldés előtt, erre a \emph{cv4s} \code{XmlSerializationHelper} modulja biztosít lehetőséget. A szerver oldalon szükség volt visszaalakítást végző, \code{OperationFactory} nevű osztály implementálására. Az osztály az \code{xml} fájl fejléce alapján határozza meg, milyen típusú művelet érkezett, és a \code{Factory} tervezési minta alapjánállítja elő az objektumot.\\
Képek küldése esetén a sorosítást az OpenCvSharp végzi el, az adat \code{byte} tömbként kerül továbbításra.

\paragraph{Konfiguráció} A szolgáltatás konfigurációját a .NET Framework által biztosított, \code{Web.config} fájl módosításával szabtam a szolgáltatás igényeire. A konfigurációs fájl egy \code{xml} fájl, amiben a \emph{service} paraméterei állíthatók be. Ez a fájl írja le többek közt, hogy mely szolgáltatásokat biztosítja a szerver, milyen elérési úton, és milyen protokollal. A feladat végrehajtásához \code{basicHttpBinding} kötést választottam, ami az elvárt működést megfelelően kielégítette. Fontos megemlíteni, hogy mivel hálózati kapcsolaton keresztül szükséges viszonylag nagyméretű képfájlok átvitele, a kapcsolat \emph{timeout} és fájlméretre vonatkozó beállításait ennek megfelelően kellett elvégezni.

\subsection{LogService}

\paragraph{Szolgáltatások} A végrehajtó eszköz távoli felügyeletét teszi lehető a feldolgozás során keletkező üzenetek továbbításával. A funkciót ellátó osztály megvalósítja a \emph{cv4s} \code{ILog} interfészét, így rugalmasságot biztosít a felhasználónak , ha esetleg nem távoli elérhetőséget lehetővé tevő alkalmazásban szeretné az \code{OperationPipeline} modult használni. Az interfész különböző szintű (\code{information}, \code{warning}, \code{error}) üzenetek továbbítását írja elő.

\paragraph{Konfiguráció} A \code{PipelineService} modul beállításaival ellentétben itt arra volt szükség, hogy a felügyelt eszközünk küldjön üzenetek, amik a kliens oldalon kerülnek megjelenítésre. A WCF lehetőséget biztosít erre ún. \code{Callback Service}-ek által, amelyek a kliens oldalon eseményeket váltanak ki.

\section{Fejlesztés menete}

A kliens oldali modul elvárt működésének érdekében \code{Service Reference} hozzáadása szükséges a projektünkhöz. Itt a szolgáltatás elérési útjának megadása után megjelenik a kívánt \code{service}, és a VisualStudio automatikusan legenerálja a szükséges kódrészleteket a használatához. Ha nem Visual Studio-t használunk lehetőség van az \code{svcutil} parancssori program alkalmazására, ami elvégzi a szolgáltatásunk kliens oldali kódjának létrehozását. \\
A tesztelés érdekében egy egyszerű parancssori

\section{\code{RpiRemoteHost}} \label{section:RpiRemoteHost}

\section{Docker}

\section{Tapasztalatok a fejlesztés során}
A fejlesztés során nehézséget jelentett, hogy a kódot Visual Studio fejlesztőkörnyezetben írtam a kódot, azonban egy másik, eltérő operációs rendszerű és architektúrájú eszközön kellett tesztelni. Emiatt a létrehoztam egy virtuális asztali Linux környezetet, lefordítva és telepítve a \ref{integracio} fejezetben leírt csomagokat. A kisebb változtatásokat és javításokat Windows és Visual Studio segítségével végeztem, majd bizonyos időközönként a virtuális Linux alatt is leteszteltem a működést. Legritkábban magán a Raspberry Pi-n futtattam a programot, mivel a \code{assembly}-k méretének és számának növekedésével egyre körülményesebbé vált a program \code{ssh}-n keresztüli átmásolása. A másolás után az eszközön a \code{mono} parancs kiadásával indítható el a kiválasztott \code{.exe} fájl. A Raspberry Pi távoli elérését a \textit{VNC Viewer} nevű alkalmazás tette lehetővé.\\
\\
A távoli elérés konfigurációja kezdetben nehezen ment részben a WCF-fel való tapasztalatlanság, részben pedig a szűk hibakeresési lehetőségek miatt. Ezért a konfigurációval kapcsolatos hibák kiküszöbölésére létrehoztam egy \code{DummyService} nevű, "állatorvosi ló" szolgáltatást, amely segítségével az átküldött adatok sorosítását és a \textit{service}-ek konfigurációját lehetett kipróbálni anélkül, hogy a lényeges funkcióval bíró szolgáltatásokat módosítani kellene.\\
\\
Kép objektumok sorosítására igyekeztem egy segédosztály létrehozására, amely elfedi a sorosítási és visszaalakítási műveleteket, azonban valamiért a modul használatával nem sikerült adatot átküldeni az eszközök között.