\chapter{Kommunikáció} \label{chapter:kommunikacio}
\section{Windows Communication Foundation}
Az eszköz távirányíthatóságát a .NET Framework \emph{Windows Communication Foundation} (WCF) nevű, szolgáltatás-orientált keretrendszerének segítségével oldottam meg. A rugalmasságot szem előtt tartva igyekeztem teljesen elkülöníteni a távoli vezérelhetőséget, illetve a \ref{chapter:kepfeldolgozo} fejezetben bemutatott képfeldolgozási funkciókat biztosító osztályokat.\\

Az elkészített szoftverkomponens bemutatása előtt pár szó a WCF-ről, illetve a mögötte lévő szoftvertervezési filozófiáról. A \ref{ssection:wcf_intro} számú bevezetőben leírt szolgáltatás-orientált szemlélet szerint készült C\# nyelven írt alkalmazások támogatására a Microsoft a WCF keretrendszert hozta létre. A keretrendszer menedzselt futási környezetet biztosít a szolgáltatások számára, amelyen keresztül azok CLR típusokat tehetnek közzé, illetve a fogadott adatot CLR típusként reprezentálhatják. Az alkalmazás komponensei nem igénylik a közös operációs rendszert, programozási nyelvet, de még azt sem, hogy egy számítógépen fussanak, elegendő a megfelelően konfigurált adatkapcsolat illetve a programozási felület (\emph{API}) ismerete. A WCF terminológiája az szoftver-egységet \emph{service}-nek (magyarul szolgáltatásnak) nevezi, és a szolgáltatás-orientált több ilyen egységet aggregál, miközben ezen egységek függőségei minimálisak. A \emph{service} ugyanis nem más mint funkcionalitások összessége, amit a komponens elérhetővé tesz a többi szolgáltatás számára, leegyszerűsítve távolról hívható függvény gyűjtemények, melyek egymástól függetlenül karban tarthatók (hasonlóan az objektumorientált szemlélet által bevezetett osztályokhoz, azonban kisebb mértékű csatolással).\\

Az így létrejövő struktúrában a szolgáltatások mellett megjelennek az őket igénybe vevő kliensek (\emph{client}), amelyek gyakorlatilag bármilyen formát ölthetnek --  Windows Forms, ASP.NET alkalmazás vagy a mi esetünkben WPF (\ref{chapter:kliens} fejezet). A \emph{service-client} architektúrában a komponenseknek egymásról csak korlátozottan van információjuk és aszinkron módon üzenetekkel kommunikálnak. A kliensek a szolgáltatások funkcionalitását és jellemzően a WCF által biztosított \emph{metaadat cserén} keresztül ismerik meg. A metaadat valamilyen technológia-független módon kerül közzétételre, és tartalmazza az adott szolgáltatás által nyújtott funkcionalitásokat, valamint a kommunikáció lehetséges módjait. \\

Általában -- és erre a megvalósított rendszernél is ki fogok térni-- a kliens nem közvetlenül a szolgáltatással kommunikál, hanem egy proxy-objektummal, amely ugyanazokkal a funkcionalitásokkal rendelkezik, mint a \emph{service} és ezen felül memória-kezelő tulajdonságai is vannak. Természetesen futási időben megismert szolgáltatás esetében nincs lehetőség a proxy-objektum definiálásra és betöltésére a memóriában, ilyenkor közvetlen kapcsolatot is létre lehet hozni a \emph{service}-szel. \cite{wcf-programming}
\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.25]{wcf_abc.pdf}
\centering
\vspace{.2cm}
\caption{WCF végpont}
\vspace{.5cm}
\label{fig:wcf_abc}
\end{figure}

Egy szolgáltatásnak a következő három három összetevőt kell definiálnia az egyértelmű azonosíthatóság érdekében:
\paragraph{Address} Minden szolgáltatáshoz tartoznia kell egy egyedi címnek, amely két fontos részletében hordoz információt a kliens számára, méghozzá a meghatározza a \emph{service} helyét (a lokális számítógépen vagy a hálózaton), illetve a kommunikáció módját az alkalmazott protokoll által. A cím mindig a következő formában írható fel:

\begin{mdframed}[backgroundcolor=gray!20]
\begin{scriptsize}
\begin{lstlisting}[language=bash]
[transport]://[machine or domain][:optional port]/[optional URI]
\end{lstlisting}
\end{scriptsize}
\end{mdframed}

A WCF által támogatott, általam használt kommunikációs sémák a HTTP/HTTPS és a TCP. (Ha lokális gépen futó kliens számára szeretnénk szolgáltatást \emph{host}-olni, az IPC (\emph{inter-process communication}), MSMQ (\emph{Microsoft Message Queue}, illetve a Service Bus kommunikációs protokollok valamelyike lehet a jó megoldás.)
\paragraph{Binding} A szolgáltatással való kommunikáció több szempontból is eltérő lehet, és sokrétűen konfigurálható. A kommunikáció iránya, az üzenetek szinkronitása és a fogadás módja szerint is részletekbe menő beállításokra van szükség a kommunikációs séma teljes körű definiáláshoz. A legtöbb alkalmazásban nincs szükség minden paraméter részletekbe menő beállítására, erre a keretrendszer előre definiált megoldásokat kínál a leggyakoribb sémákra, amelyek a fentebb leírt kommunikációs protokollokra definiálnak egy-egy sémát, amelyet igény szerint tovább finomíthatunk.
\paragraph{Contract} Platformfüggetlen \emph{szerződésként} írja le a szolgáltatás képességeit a kliens számára. Az objektumorientált szemléletben használt interfészekkel állítható párhuzamba -- megvalósítása objektumorientált nyelven (esetünkben C\#) gyakorlatilag is interfészekkel történik. A WCF négyféle \emph{contract} típust definiál, melyek a 
\begin{itemize}
\setlength\itemsep{.1em}
\item \emph{Service contract} Meghatározza, milyen funkcionalitásokra képes a szolgáltatás. Az osztályunk által definiált CLR interfészt összerendeli a szolgáltatás technológia-független interfészével. 
\item \emph{Data contract} A szolgáltatás által használt adattípusukat definiálja. A CLR beépített típusai alapértelmezetten ismertek a keretrendszer számára.
\item \emph{Fault contract} A \emph{service} oldali hibák kliens oldalon való jelzésére szolgáló megegyezés.
\item \emph{Message contract}. Szolgáltatások közvetlen, üzenet alapú kölcsönhatását teszi lehetővé. 
\end{itemize}
Ezek közül a lehetőségek közül a diplomamunkámban két típust, a \emph{service} és \emph{data contract}-ot használtam fel.

E három komponens együttesen egy \emph{végpontot} (\emph{endpoint}-ot) definiál a \ref{fig:wcf_abc} ábrán látható módon.
A végpontot azonosító három összetevő egyenként is számos eltérő beállítási lehetőséget nyújt, azonban összességében nézve szinte teljeskörűen az alkalmazásra szabható konfigurációt kapunk.\\
Fontos megjegyezni, hogy minden \emph{service}-hez tartoznia kell legalább egy -- de akár több -- \emph{endpoint}-nak. A szolgáltatást futtató \emph{host} ezeket a végpontokat teszi elérhetővé a kliensek számára a már említett metaadat cserén keresztül. A kliens a metaadathoz is a szolgáltatás speciális, \emph{MEX}, azaz \emph{metadata exchange} végpontján keresztül fér hozzá. A végpontok konfigurációja a szolgáltatás megvalósítása során az egyik legfontosabb lépés, erre a WCF keretrendszer két módot is kínál: programkódból történő, illetve adminisztratív beállítást. A különbség a két módszer között annyi, hogy míg az előbbi esetben a konfigurációt reprezentáló objektumokat a forráskódban explicit létrehozzuk, az utóbbi módszerrel a példányosítást a keretrendszerre bízzuk, az egyes paramétereket pedig XML formátumú konfigurációs fájlban adjuk át neki. Az utóbbi eset jelentős előnye, hogy a szoftver ebben az esetben nem függ a kommunikáció paramétereitől, a konfiguráció-változtatás pedig a gyakorlatban egyetlen fájl cseréjét jelenti. \\
\\
A WCF architektúrában az üzenetek eljuttatása a klienstől a szolgáltatásig a \ref{fig:wcf_architekture} ábrán bemutatott módon, úgynevezett \code{Channel} objektumokon keresztül történik. Látható, hogy a kliens vagy egy helyettes, a szolgáltatást reprezentáló objektumon keresztül vagy közvetlenül kommunikál a legfelső \code{Channel}-lel

\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.25]{wcf_architekture.pdf}
\centering
\vspace{.2cm}
\caption{WCF kommunikációs architektúra}
\vspace{.5cm}
\label{fig:wcf_architekture}
\end{figure}

A WCF architektúrában a Raspberry Pi-n futó képfeldolgozó alkalmazás a \textit{service} szerepét tölti be, a felügyelő feladatot ellátó, asztali gépen futó alkalmazás pedig kliensként veszi igénybe annak szolgáltatásait.\\
Az alább bemutatott szolgáltatások a egy-egy \code{ServiceContract} attribútummal ellátott interfész implementálásával, illetve konfigurációs fájl hozzáadásával válnak távolról elérhető szolgáltatásokká.

\section{Kommunikációs architektúra -- REST vs SOAP}

\section{Megvalósított \emph{service}-ek és konfigurációjuk}
A WCF dokumentációja szolgáltatások létrehozására megvalósítására két lehetséges módot biztosít: a \emph{service} deklarálása interfészként vagy osztályként. Mindenkét esetben a \code{[ServiceContract]} attribútumot kell alkalmazni az adott típusra, de az újrafelhasználhatóság szempontjából az interfészek használata a javasolt, így a diplomamunkámban a dokumentáció iránymutatását követtem. Összesen négy darab \emph{Service Contract} interfészt definiáltam, amelyek közül egyszerre három fut az eszközben. 
\subsection{PipelineService}

\paragraph{Szolgáltatások}
A képfeldolgozó modul távoli vezérelhetőségét a \code{PipelineService} osztály biztosítja azáltal, hogy megvalósítja a a \code{IPipelineService} \textit{szerződését}. Ezáltal a következő műveletek lesznek elérhetőek interneten keresztül:
\begin{itemize}
\item művelet hozzáfűzése a végrehajtási lánc végéhez
\item művelet beszúrása megadott pozícióba a műveleti listába
\item művelet eltávolítása a műveletek közül
\item műveleti sor teljes frissítése egy lista alapján
\item képernyőkép lekérése az utolsó feldolgozott képkockával
\end{itemize}

A kliens oldalon konfigurált képfeldolgozási művelet \code{xml} formátummá konvertálódik a küldés előtt, erre a \emph{cv4s} \code{XmlSerializationHelper} modulja biztosít lehetőséget. A szerver oldalon szükség volt visszaalakítást végző, \code{OperationFactory} nevű osztály implementálására. Az osztály az \code{xml} fájl fejléce alapján határozza meg, milyen típusú művelet érkezett, és a \code{Factory} tervezési minta alapjánállítja elő az objektumot.\\
Képek küldése esetén a sorosítást az OpenCvSharp végzi el, az adat \code{byte} tömbként kerül továbbításra.

\paragraph{Konfiguráció} A szolgáltatás konfigurációját a .NET Framework által biztosított, \code{Web.config} fájl módosításával szabtam a szolgáltatás igényeire. A konfigurációs fájl egy \code{xml} fájl, amiben a \emph{service} paraméterei állíthatók be. Ez a fájl írja le többek közt, hogy mely szolgáltatásokat biztosítja a szerver, milyen elérési úton, és milyen protokollal. A feladat végrehajtásához \code{basicHttpBinding} kötést választottam, ami az elvárt működést megfelelően kielégítette. Fontos megemlíteni, hogy mivel hálózati kapcsolaton keresztül szükséges viszonylag nagyméretű képfájlok átvitele, a kapcsolat \emph{timeout} és fájlméretre vonatkozó beállításait ennek megfelelően kellett elvégezni.

\subsubsection{A műveleteket előállító osztály tesztelése}
\code{OperationFactoryTests}

\subsection{LogService}
\paragraph{Szolgáltatások} A végrehajtó eszköz távoli felügyeletét teszi lehető a feldolgozás során keletkező üzenetek továbbításával. A funkciót ellátó osztály megvalósítja a \emph{cv4s} \code{ILog} interfészét, így rugalmasságot biztosít a felhasználónak , ha esetleg nem távoli elérhetőséget lehetővé tevő alkalmazásban szeretné az \code{OperationPipeline} modult használni. Az interfész különböző szintű (\code{information}, \code{warning}, \code{error}) üzenetek továbbítását írja elő.

\paragraph{Konfiguráció} A \code{PipelineService} modul beállításaival ellentétben itt arra volt szükség, hogy a felügyelt eszközünk küldjön üzenetek, amik a kliens oldalon kerülnek megjelenítésre. A WCF lehetőséget biztosít erre ún. \code{Callback Service}-ek által, amelyek a kliens oldalon eseményeket váltanak ki.

\subsection{PollLogService}

\subsection{SnapshotService}

\section{Fejlesztés menete}

A kliens oldali modul elvárt működésének érdekében \code{Service Reference} hozzáadása szükséges a projektünkhöz. Itt a szolgáltatás elérési útjának megadása után megjelenik a kívánt \code{service}, és a VisualStudio automatikusan legenerálja a szükséges kódrészleteket a használatához. Ha nem Visual Studio-t használunk lehetőség van az \code{svcutil} parancssori program alkalmazására, ami elvégzi a szolgáltatásunk kliens oldali kódjának létrehozását. \\
A tesztelés érdekében egy egyszerű parancssori

\section{\code{RpiRemoteHost}} \label{section:RpiRemoteHost}

\section{Docker}

\section{Tapasztalatok a fejlesztés során}
A fejlesztés során nehézséget jelentett, hogy a kódot Visual Studio fejlesztőkörnyezetben írtam a kódot, azonban egy másik, eltérő operációs rendszerű és architektúrájú eszközön kellett tesztelni. Emiatt a létrehoztam egy virtuális asztali Linux környezetet, lefordítva és telepítve a \ref{integracio} fejezetben leírt csomagokat. A kisebb változtatásokat és javításokat Windows és Visual Studio segítségével végeztem, majd bizonyos időközönként a virtuális Linux alatt is leteszteltem a működést. Legritkábban magán a Raspberry Pi-n futtattam a programot, mivel a \code{assembly}-k méretének és számának növekedésével egyre körülményesebbé vált a program \code{ssh}-n keresztüli átmásolása. A másolás után az eszközön a \code{mono} parancs kiadásával indítható el a kiválasztott \code{.exe} fájl. A Raspberry Pi távoli elérését a \textit{VNC Viewer} nevű alkalmazás tette lehetővé.\\
\\
A távoli elérés konfigurációja kezdetben nehezen ment részben a WCF-fel való tapasztalatlanság, részben pedig a szűk hibakeresési lehetőségek miatt. Ezért a konfigurációval kapcsolatos hibák kiküszöbölésére létrehoztam egy \code{DummyService} nevű, "állatorvosi ló" szolgáltatást, amely segítségével az átküldött adatok sorosítását és a \textit{service}-ek konfigurációját lehetett kipróbálni anélkül, hogy a lényeges funkcióval bíró szolgáltatásokat módosítani kellene.\\
\\
Kép objektumok sorosítására igyekeztem egy segédosztály létrehozására, amely elfedi a sorosítási és visszaalakítási műveleteket, azonban valamiért a modul használatával nem sikerült adatot átküldeni az eszközök között.
