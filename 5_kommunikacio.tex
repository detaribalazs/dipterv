\chapter{Kommunikáció} \label{chapter:kommunikacio}
\section{Windows Communication Foundation}
Az eszköz távirányíthatóságát a .NET Framework \emph{Windows Communication Foundation} (WCF) nevű, szolgáltatás-orientált keretrendszerének segítségével oldottam meg. A rugalmasságot szem előtt tartva igyekeztem teljesen elkülöníteni a távoli vezérelhetőséget, illetve a \ref{chapter:kepfeldolgozo} fejezetben bemutatott képfeldolgozási funkciókat biztosító osztályokat.\\

Az elkészített szoftverkomponens bemutatása előtt pár szó a WCF-ről, illetve a mögötte lévő szoftvertervezési filozófiáról. A \ref{ssection:wcf_intro} számú bevezetőben leírt szolgáltatás-orientált szemlélet szerint készült C\# nyelven írt alkalmazások támogatására a Microsoft a WCF keretrendszert hozta létre. A keretrendszer menedzselt futási környezetet biztosít a szolgáltatások számára, amelyen keresztül azok CLR típusokat tehetnek közzé, illetve a fogadott adatot CLR típusként reprezentálhatják. Az alkalmazás komponensei nem igénylik a közös operációs rendszert, programozási nyelvet, de még azt sem, hogy egy számítógépen fussanak, elegendő a megfelelően konfigurált adatkapcsolat illetve a programozási felület (\emph{API}) ismerete. A WCF terminológiája az szoftver-egységet \emph{service}-nek (magyarul szolgáltatásnak) nevezi, és a szolgáltatás-orientált több ilyen egységet aggregál, miközben ezen egységek függőségei minimálisak. A \emph{service} ugyanis nem más mint funkcionalitások összessége, amit a komponens elérhetővé tesz a többi szolgáltatás számára, leegyszerűsítve távolról hívható függvény gyűjtemények, melyek egymástól függetlenül karban tarthatók (hasonlóan az objektumorientált szemlélet által bevezetett osztályokhoz, azonban kisebb mértékű csatolással).\\

Az így létrejövő struktúrában a szolgáltatások mellett megjelennek az őket igénybe vevő kliensek (\emph{client}), amelyek gyakorlatilag bármilyen formát ölthetnek --  Windows Forms, ASP.NET alkalmazás vagy a mi esetünkben WPF (\ref{chapter:kliens} fejezet). A \emph{service-client} architektúrában a komponenseknek egymásról csak korlátozottan van információjuk és aszinkron módon üzenetekkel kommunikálnak. A kliensek a szolgáltatások funkcionalitását és jellemzően a WCF által biztosított \emph{metaadat cserén} keresztül ismerik meg. A metaadat valamilyen technológia-független módon kerül közzétételre, és tartalmazza az adott szolgáltatás által nyújtott funkcionalitásokat, valamint a kommunikáció lehetséges módjait. \\

Általában -- és erre a megvalósított rendszernél is ki fogok térni-- a kliens nem közvetlenül a szolgáltatással kommunikál, hanem egy proxy-objektummal, amely ugyanazokkal a funkcionalitásokkal rendelkezik, mint a \emph{service} és ezen felül memória-kezelő tulajdonságai is vannak. Természetesen futási időben megismert szolgáltatás esetében nincs lehetőség a proxy-objektum definiálásra és betöltésére a memóriában, ilyenkor közvetlen kapcsolatot is létre lehet hozni a \emph{service}-szel. \cite{wcf-programming}
\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.25]{wcf_abc.pdf}
\centering
\vspace{.2cm}
\caption{WCF végpont}
\vspace{.5cm}
\label{fig:wcf_abc}
\end{figure}

Egy szolgáltatásnak a következő három három összetevőt kell definiálnia az egyértelmű azonosíthatóság érdekében:
\paragraph{Address} Minden szolgáltatáshoz tartoznia kell egy egyedi címnek, amely két fontos részletében hordoz információt a kliens számára, méghozzá a meghatározza a \emph{service} helyét (a lokális számítógépen vagy a hálózaton), illetve a kommunikáció módját az alkalmazott protokoll által. A cím mindig a következő formában írható fel:

\begin{mdframed}[backgroundcolor=gray!20]
\begin{scriptsize}
\begin{lstlisting}[language=bash]
[transport]://[machine or domain][:optional port]/[optional URI]
\end{lstlisting}
\end{scriptsize}
\end{mdframed}

A WCF által támogatott, általam használt kommunikációs sémák a HTTP/HTTPS és a TCP. (Ha lokális gépen futó kliens számára szeretnénk szolgáltatást \emph{host}-olni, az IPC (\emph{inter-process communication}), MSMQ (\emph{Microsoft Message Queue}, illetve a Service Bus kommunikációs protokollok valamelyike lehet a jó megoldás.)
\paragraph{Binding} A szolgáltatással való kommunikáció több szempontból is eltérő lehet, és sokrétűen konfigurálható. A kommunikáció iránya, az üzenetek szinkronitása és a fogadás módja szerint is részletekbe menő beállításokra van szükség a kommunikációs séma teljes körű definiáláshoz. A legtöbb alkalmazásban nincs szükség minden paraméter részletekbe menő beállítására, erre a keretrendszer előre definiált megoldásokat kínál a leggyakoribb sémákra, amelyek a fentebb leírt kommunikációs protokollokra definiálnak egy-egy sémát, amelyet igény szerint tovább finomíthatunk.
\paragraph{Contract} Platformfüggetlen \emph{szerződésként} írja le a szolgáltatás képességeit a kliens számára. Az objektumorientált szemléletben használt interfészekkel állítható párhuzamba -- megvalósítása objektumorientált nyelven (esetünkben C\#) gyakorlatilag is interfészekkel történik. A WCF négyféle \emph{contract} típust definiál, melyek a 
\begin{itemize}
\setlength\itemsep{.1em}
\item \emph{Service contract} Meghatározza, milyen funkcionalitásokra képes a szolgáltatás. Az osztályunk által definiált CLR interfészt összerendeli a szolgáltatás technológia-független interfészével. 
\item \emph{Data contract} A szolgáltatás által használt adattípusukat definiálja. A CLR beépített típusai alapértelmezetten ismertek a keretrendszer számára.
\item \emph{Fault contract} A \emph{service} oldali hibák kliens oldalon való jelzésére szolgáló megegyezés.
\item \emph{Message contract}. Szolgáltatások közvetlen, üzenet alapú kölcsönhatását teszi lehetővé. 
\end{itemize}
Ezek közül a lehetőségek közül a diplomamunkámban két típust, a \emph{service} és \emph{data contract}-ot használtam fel.

E három komponens együttesen egy \emph{végpontot} (\emph{endpoint}-ot) definiál a \ref{fig:wcf_abc} ábrán látható módon.
A végpontot azonosító három összetevő egyenként is számos eltérő beállítási lehetőséget nyújt, azonban összességében nézve szinte teljeskörűen az alkalmazásra szabható konfigurációt kapunk.\\
Fontos megjegyezni, hogy minden \emph{service}-hez tartoznia kell legalább egy -- de akár több -- \emph{endpoint}-nak. A szolgáltatást futtató \emph{host} ezeket a végpontokat teszi elérhetővé a kliensek számára a már említett metaadat cserén keresztül. A kliens a metaadathoz is a szolgáltatás speciális, \emph{MEX}, azaz \emph{metadata exchange} végpontján keresztül fér hozzá. A végpontok konfigurációja a szolgáltatás megvalósítása során az egyik legfontosabb lépés, erre a WCF keretrendszer két módot is kínál: programkódból történő, illetve adminisztratív beállítást. A különbség a két módszer között annyi, hogy míg az előbbi esetben a konfigurációt reprezentáló objektumokat a forráskódban explicit létrehozzuk, az utóbbi módszerrel a példányosítást a keretrendszerre bízzuk, az egyes paramétereket pedig XML formátumú konfigurációs fájlban adjuk át neki. Az utóbbi eset jelentős előnye, hogy a szoftver ebben az esetben nem függ a kommunikáció paramétereitől, a konfiguráció-változtatás pedig a gyakorlatban egyetlen fájl cseréjét jelenti. \cite{wcf-doc} \\
\\
A WCF architektúrában az üzenetek eljuttatása a klienstől a szolgáltatásig a \ref{fig:wcf_architekture} ábrán bemutatott módon, úgynevezett \code{Channel} objektumokon keresztül történik. Látható, hogy a kliens vagy egy helyettes, a szolgáltatást reprezentáló objektumon keresztül vagy közvetlenül kommunikál a legfelső \code{Channel}-lel. Ezek az objektumok reprezentálják a konfigurációnak megfelelő kommunikáció egyes lépéseit, a klienstől jövő üzeneteket a transzport csatornáig eljutva a megfelelő formátumúra alakítják; struktúrájuk nagyrészt a \emph{Binding} konfigurációjától függ. A \emph{service} oldalon az üzenet fordított sorrendben végrehajtva az előző transzformációkat visszakapjuk a kliens üzenetét, amit a \code{Dispatecher} objektum ad át a szolgáltatás megfelelő végpontján. A \emph{service}-t valójában közvetlenül egy lokális kliens hívja meg -- a diszpécser. A szolgáltatás által a hívásra adott válasz a \ref{fig:wcf_architekture} ábrán látható úton ellentétes irányban jut el a klienshez. \cite{wcf-programming}

\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.1]{wcf_architekture.pdf}
\centering
\vspace{.2cm}
\caption{WCF kommunikációs architektúra}
\vspace{.5cm}
\label{fig:wcf_architekture}
\end{figure}

A diplomaterv keretében megvalósított alkalmazás esetén a Raspberry Pi-n futó képfeldolgozó szoftver látja el a  \emph{service} szerepét, a felügyelő feladatot ellátó, asztali gépen futó alkalmazás pedig kliensként veszi igénybe annak szolgáltatásait, amelyeket a \ref{section:servicek} alfejezet részletez.

\section{Kommunikációs protokoll}

A keretrendszer kiválasztása után, az implementálás előtti utolsó lépés a kommunikációs protokoll tisztázása volt. A WCF által támogatott hálózati protokollok közül a TCP és a HTTP közül mindkettő jó választás lehet, a weben HTTP szélesebb körben támogatott, alkalmazásrétegbeli protokoll, a TCP pedig ipari alkalmazásokhoz jobban illeszkedő, szállítási rétegbeli protokoll. A WCF konfigurációja lehetővé teszi, hogy a fejlesztő számára a különbség csak a konfigurációs fájl szintjén jelentkezzen, ezért az implementál szolgáltatások számára mindkét protokollon keresztül nyitottam egy-egy végpontot.\\
A leírt hálózati kapcsolaton menő üzenetek tartalmát az XML-alapú \emph{SOAP} üzenetek (\emph{Simple Object Access Protocol}) határozza meg. A SOAP speciálisan webszolgáltatások számára kifejlesztett, strukturált adatot tartalmazó üzenetekkel kommunikáló protokoll, amely a már említett WSDL-hez hasonlóan valamilyen alkalmazásrétegbeli protokoll fölött működik. Egyes webes szolgáltatások számára a SOAP túlságosan merev, összehasonlítva a REST kommunikációs architektúra kínálta rugalmassággal. SOAP használata esetén ugyanis a \emph{service} és a \emph{client} együttes, párhuzamos fejlesztése a legcélravezetőbb a nagyfokú csatoltság miatt. A Raspberry-n futó képfeldolgozó alkalmazás esetében szerencsére ez a helyzet, és a WCF esetében is ez az alap beállítás, így végül majdnem minden megvalósított szolgáltatás a \code{BasicHttpBinding} kötést használja eltérő beállításokkal.\\
A SOAP üzenetek technológia független módon képesek üzenet alapú kommunikációra. Három főbb érszből áll:
\begin{itemize}
\item egy \emph{boríték}, mely a az üzenet struktúrát és a feldolgozás módját definiálja
\item az alkalmazás-specifikus adattípusokra vonatkozó kódolás
\item a távoli eljárások hívására és a válaszok formátumára vonatkozó megegyezés
\end{itemize}
A protokoll üzeneteinek struktúrája a \ref{figure:soap_message} ábrán látható. A WCF keretrendszer az üzeneteket a megfelelő \emph{binding}-nak megfelelően a háttérben előállítja, így alapesetben a fejlesztőnek nem kell ismernie, viszont a program Raspbian-ra való integrálása során a nem megfelelő üzenetformátumból adódtak problémák. A SOAP-üzenetek megvizsgálása után a kapcsolat paramétereinek megfelelő változtatása orvosolta a problémát.

\begin{figure}[h]
\centering
\begin{minipage}{0.73\textwidth}
\begin{mdframed}[backgroundcolor=gray!20]
\begin{scriptsize}
\begin{lstlisting}[language=XML]
<?xml version="1.0"?>
<soap:Envelope xmlns:soap=
  "http://www.w3.org/2003/05/soap-envelope">
  <soap:Header>
  	<!-- Header nodes -->
  </soap:Header>
  <soap:Body>
    <!-- Object properties -->
  </soap:Body>
</soap:Envelope>
\end{lstlisting}
\end{scriptsize}
\end{mdframed}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}{0.21\textwidth}
\includegraphics[height=4.3cm]{soap_message.pdf}
\end{minipage}
\caption{SOAP üzenetek felépítése}
\label{figure:soap_message}
\end{figure}

\section{Szolgáltatások} \label{section:servicek}
A WCF dokumentációja szolgáltatások létrehozására megvalósítására két lehetséges módot biztosít: a \emph{service} deklarálása interfészként vagy osztályként. Mindenkét esetben a \code{[ServiceContract]} attribútumot kell alkalmazni az adott típusra, de az újrafelhasználhatóság szempontjából az interfészek használata a javasolt, így a diplomamunkámban a dokumentáció iránymutatását követtem. \cite{wcf-doc} \\
Összesen négy darab \emph{Service Contract} interfészt definiáltam, amelyek közül egy időben hármat használ az alkalmazás. A szolgáltatás funkcionalitását adó távolról hívható metódusok a \code{[ServiceContract]} interfész azon tagfüggvényei lesznek, amelyeket az \code{[OperationContract]} attribútummal megjelölünk. A szoftver struktúrájának szempontjából a definiált szolgáltatások a \code{Rpi.Service} névtérben, a \code{RpiServices} \emph{assembly}-ben lettek deklarálva.\\
\\
Az implementált szolgáltatások közös vonása, hogy mindegyikük tervezéséhez a \emph{singleton} (magyarul egyke) tervezési mintát vettem alapul. Mivel a beágyazott számítógépen a szolgáltatások egyetlen képfeldolgozó folyamat vezérlésére szolgálnak (erre a \emph{use-case} által definiált egyetlen kamera jelenlétéből következtethetünk), így az egyedülálló művelet bizonyos attribútumainak változtatásához is elég egy-egy távolról elérhető szolgáltatás. A \emph{singleton} tervezési minta pontosan azt írja elő, hogy egy osztályt legfeljebb egyszer lehet példányosítani, így egy programban legfeljebb egyetlen adott típusú objektum lehet. Gyakorlati megvalósítása a konstruktor priváttá tételével és egy, az osztály típusával megegyező statikus tagváltozó hozzáadásával érhető el. A statikus adattag referencia az egyetlen példányra, vagy \code{null}. A példányhoz a publikus \code{GetInstance()} tagfüggvény segítségével férhetünk hozzá, amely visszaadja a példányt, amennyiben létezik, ha pedig nem, a privát konstruktorral példányosítja és visszaadja az új példányt, miután a statikus referenciát ráállította. \footnote{A tervezési minta által meghatározott tagváltozók és tagfüggvények a fejezet osztálydiagramjain a \ref{fig:PipelineService_class} ábrán kívül nem kerültek megjelenítésre.}

\subsection{\code{PipelineService}}

A távoli gépen futó csővezeték konfigurációjára szolgáló programozási felületet definiálja. A \ref{fig:PipelineService_class} ábrán látható módon a szolgáltatás az \code{IPipelineService} \emph{service contract} implementálásával jön létre. Az interfészre és definiált tagfüggvényeire is alkalmaztam a \ref{section:servicek} alfejezet bevezetőjében tárgyal attribútumokat.

\begin{figure}[h]
\vspace{.5cm}
\includegraphics[scale=1.1]{PipelineService.pdf}
\centering
\vspace{.2cm}
\caption{\code{PipelineService} szolgáltatás}
\vspace{.5cm}
\label{fig:PipelineService_class}
\end{figure}

\subsubsection{\code{}}

\subsection{\code{PipelineService}}



\paragraph{Szolgáltatások}
A képfeldolgozó modul távoli vezérelhetőségét a \code{PipelineService} osztály biztosítja azáltal, hogy megvalósítja a a \code{IPipelineService} \textit{szerződését}. Ezáltal a következő műveletek lesznek elérhetőek interneten keresztül:
\begin{itemize}
\item művelet hozzáfűzése a végrehajtási lánc végéhez
\item művelet beszúrása megadott pozícióba a műveleti listába
\item művelet eltávolítása a műveletek közül
\item műveleti sor teljes frissítése egy lista alapján
\item képernyőkép lekérése az utolsó feldolgozott képkockával
\end{itemize}

A kliens oldalon konfigurált képfeldolgozási művelet \code{xml} formátummá konvertálódik a küldés előtt, erre a \emph{cv4s} \code{XmlSerializationHelper} modulja biztosít lehetőséget. A szerver oldalon szükség volt visszaalakítást végző, \code{OperationFactory} nevű osztály implementálására. Az osztály az \code{xml} fájl fejléce alapján határozza meg, milyen típusú művelet érkezett, és a \code{Factory} tervezési minta alapjánállítja elő az objektumot.\\
Képek küldése esetén a sorosítást az OpenCvSharp végzi el, az adat \code{byte} tömbként kerül továbbításra.

\paragraph{Konfiguráció} A szolgáltatás konfigurációját a .NET Framework által biztosított, \code{Web.config} fájl módosításával szabtam a szolgáltatás igényeire. A konfigurációs fájl egy \code{xml} fájl, amiben a \emph{service} paraméterei állíthatók be. Ez a fájl írja le többek közt, hogy mely szolgáltatásokat biztosítja a szerver, milyen elérési úton, és milyen protokollal. A feladat végrehajtásához \code{basicHttpBinding} kötést választottam, ami az elvárt működést megfelelően kielégítette. Fontos megemlíteni, hogy mivel hálózati kapcsolaton keresztül szükséges viszonylag nagyméretű képfájlok átvitele, a kapcsolat \emph{timeout} és fájlméretre vonatkozó beállításait ennek megfelelően kellett elvégezni.

\subsubsection{A műveleteket előállító osztály tesztelése}
\code{OperationFactoryTests}

\subsection{LogService}
\paragraph{Szolgáltatások} A végrehajtó eszköz távoli felügyeletét teszi lehető a feldolgozás során keletkező üzenetek továbbításával. A funkciót ellátó osztály megvalósítja a \emph{cv4s} \code{ILog} interfészét, így rugalmasságot biztosít a felhasználónak , ha esetleg nem távoli elérhetőséget lehetővé tevő alkalmazásban szeretné az \code{OperationPipeline} modult használni. Az interfész különböző szintű (\code{information}, \code{warning}, \code{error}) üzenetek továbbítását írja elő.

\paragraph{Konfiguráció} A \code{PipelineService} modul beállításaival ellentétben itt arra volt szükség, hogy a felügyelt eszközünk küldjön üzenetek, amik a kliens oldalon kerülnek megjelenítésre. A WCF lehetőséget biztosít erre ún. \code{Callback Service}-ek által, amelyek a kliens oldalon eseményeket váltanak ki.

\subsection{PollLogService}

\subsection{SnapshotService}

\section{\code{RpiRemoteHost}} \label{section:RpiRemoteHost}

A \ref{chapter:kepfeldolgozo} és \ref{chapter:kommunikacio} fejezet korábbi részeiben leírt funkcionalitások alkalmazásba való aggregálásért felelő osztály. Ő felelős az erőforrások inicializálásért, a csővezeték és a kamera olvasó osztály felügyeletéért, valamint a kommunikációs csatornák kezeléséért. Az osztályt a Raspberry Pi-n futó fű alkalmazás példányosítja a kívánt konfigurációval. A megvalósított osztály di

\subsection{Parancssori interfész}

Mivel az eszköz a felhasználói eset szerint nehezen hozzáférhető helyen található, gondoskodni kellett a távirányítható alkalmazás távolról, konfigurálható paraméterekkel történő indításáról is. Előfordulhat ugyanis, hogy a program olyan állapotba kerül, amelyből már csak az újraindításával lehet visszatérni az elvárt működéshez. Ehhez készítettem egy, a GNU/Linux operációs rendszeren megszokott paraméterstruktúrával rendelkező \emph{CLI}-t (\emph{command line interface}-t). A leírt paraméterekkel összeállított parancsot távoli gépről \code{ssh} paranccsal adhatjuk ki az eszközön. A szabványos .NET Framework-ben sajnos nincs hasonló parancssori támogatást nyújtó osztálykönyvtár, így a \code{Mono.Options}  nevű csomagot használtam -- amely a Mono keretrendszer része, és ennek megfelelően nyílt forráskódú --, ennek segítségével egyszerűen elkészíthető készíthető következő paraméterekkel rendelkező interfész:

\begin{figure}[h]
\centering
\begin{minipage}{1\textwidth}
\begin{mdframed}[backgroundcolor=gray!20]
\begin{scriptsize}
\begin{lstlisting}[language=xml]
  -l, --location=VALUE       Path to the video file to play.
  -p, --poll                 Use the poll log service. If false, duplex binding is
  			     required.
  -v, --verbosity=VALUE      Use this verbosity level.
  -f, --fps=VALUE            Framerate for the camera reader.
  -h, --help                 Show this message and exit
\end{lstlisting}
\end{scriptsize}
\end{mdframed}
\end{minipage}
\caption{CLI segítség menüje} \label{figure:cli_help}
\end{figure}

Az "-l" kapcsolóval a fájl helyét lehet megadni, ahol a kiolvasandó videostream található, ez lehet Linuxon eszköz helye, vagy egy létező videofájl a fájlrendszerben.
A "-p" paraméterrel azt szabályozhatjuk, hogy a \emph{service}-ünk naplóüzenet szolgáltatása kétirányú kapcsolatot nyisson vagy a kliens által lekérdezendő legyen.
A "-v" kapcsoló mellé szükséges egy pozitív egész szám, ami a \emph{service} oldali naplózás szintjét állítja be. Alapesetben érdemes az alapértelmezett "\emph{verbose}" szinten hagyni, és a kliens oldalon kiszűrni a szükségtelen üzeneteket. 
Beállítható még továbbá a csővezeték indításakor használt kiolvasási sebesség, ami képkocka/másodperc dimenzióval értendő.
A program paramétereiről összefoglaló információt a "-h" kapcsolóval kérhetünk, ekkor a \ref{figure:cli_help} ábrán látható üzenetet kapjuk.

\section{Fejlesztés menete}

A kliens oldali modul elvárt működésének érdekében \code{Service Reference} hozzáadása szükséges a projektünkhöz. Itt a szolgáltatás elérési útjának megadása után megjelenik a kívánt \code{service}, és a VisualStudio automatikusan legenerálja a szükséges kódrészleteket a használatához. Ha nem Visual Studio-t használunk lehetőség van az \code{svcutil} parancssori program alkalmazására, ami elvégzi a szolgáltatásunk kliens oldali kódjának létrehozását. \\
A tesztelés érdekében egy egyszerű parancssori

\section{Docker}

\section{Tapasztalatok a fejlesztés során}
A fejlesztés során nehézséget jelentett, hogy a kódot Visual Studio fejlesztőkörnyezetben írtam a kódot, azonban egy másik, eltérő operációs rendszerű és architektúrájú eszközön kellett tesztelni. Emiatt a létrehoztam egy virtuális asztali Linux környezetet, lefordítva és telepítve a \ref{integracio} fejezetben leírt csomagokat. A kisebb változtatásokat és javításokat Windows és Visual Studio segítségével végeztem, majd bizonyos időközönként a virtuális Linux alatt is leteszteltem a működést. Legritkábban magán a Raspberry Pi-n futtattam a programot, mivel a \code{assembly}-k méretének és számának növekedésével egyre körülményesebbé vált a program \code{ssh}-n keresztüli átmásolása. A másolás után az eszközön a \code{mono} parancs kiadásával indítható el a kiválasztott \code{.exe} fájl. A Raspberry Pi távoli elérését a \textit{VNC Viewer} nevű alkalmazás tette lehetővé.\\
\\
A távoli elérés konfigurációja kezdetben nehezen ment részben a WCF-fel való tapasztalatlanság, részben pedig a szűk hibakeresési lehetőségek miatt. Ezért a konfigurációval kapcsolatos hibák kiküszöbölésére létrehoztam egy \code{DummyService} nevű, "állatorvosi ló" szolgáltatást, amely segítségével az átküldött adatok sorosítását és a \textit{service}-ek konfigurációját lehetett kipróbálni anélkül, hogy a lényeges funkcióval bíró szolgáltatásokat módosítani kellene.\\
\\
Kép objektumok sorosítására igyekeztem egy segédosztály létrehozására, amely elfedi a sorosítási és visszaalakítási műveleteket, azonban valamiért a modul használatával nem sikerült adatot átküldeni az eszközök között.
